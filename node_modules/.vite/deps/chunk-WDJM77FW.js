import {
  BN_EIGHT,
  BigInt as BigInt2,
  RistrettoPoint,
  _0n,
  _1n,
  aInRange,
  base58,
  base64,
  bip39Generate,
  bip39ToEntropy,
  bip39ToMiniSecret,
  bip39ToSeed,
  bip39Validate,
  bitMask,
  blake2b,
  blake2b2,
  bnToU8a,
  bytesToNumberLE,
  compactAddLength,
  compactToU8a,
  concatBytes,
  detectPackage,
  ed25519,
  ed25519KeypairFromSeed,
  ed25519Sign,
  ed25519Verify,
  esm_default,
  exposeGlobal,
  getRandomValues,
  hasBigInt,
  hexToBn,
  hexToU8a,
  hmac,
  hmacSha256,
  hmacSha512,
  import_bn,
  isBigInt,
  isBn,
  isBytes,
  isHex,
  isNumber,
  isReady,
  isString,
  isU8a,
  keccak256,
  keccak512,
  keccakP,
  keccak_256,
  keccak_512,
  logger,
  mod,
  nToU8a,
  numberToBytesLE,
  objectSpread,
  packageInfo,
  packageInfo2,
  pbkdf2,
  pbkdf22,
  randomBytes,
  scrypt,
  scrypt2,
  secp256k1,
  secp256k1Compress,
  secp256k1Expand,
  secp256k1FromSeed,
  secp256k1Recover,
  secp256k1Sign,
  sha256,
  sha2562,
  sha512,
  sha5122,
  stringToU8a,
  twox,
  u32,
  u8aConcat,
  u8aConcatStrict,
  u8aEmpty,
  u8aEq,
  u8aFixLength,
  u8aIsWrapped,
  u8aSorted,
  u8aToBigInt,
  u8aToBn,
  u8aToHex,
  u8aToU8a,
  u8aUnwrapBytes,
  u8aWrapBytes,
  utf8ToBytes,
  utils,
  waitReady
} from "./chunk-FZBI2DIJ.js";
import {
  __privateAdd,
  __privateGet,
  __privateSet
} from "./chunk-WOOG5QLI.js";

// node_modules/@polkadot/networks/packageInfo.js
var packageInfo3 = { name: "@polkadot/networks", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "14.0.1" };

// node_modules/@polkadot/util-crypto/packageInfo.js
var packageInfo4 = { name: "@polkadot/util-crypto", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "14.0.1" };

// node_modules/@polkadot/util-crypto/packageDetect.js
detectPackage(packageInfo4, null, [packageInfo3, packageInfo2, packageInfo]);

// node_modules/@polkadot/x-bigint/shim.js
exposeGlobal("BigInt", BigInt2);

// node_modules/@polkadot/util-crypto/crypto.js
var cryptoIsReady = isReady;
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error("Unable to initialize @polkadot/util-crypto");
    }
    return true;
  }).catch(() => false);
}

// node_modules/@polkadot/util-crypto/bundleInit.js
cryptoWaitReady().catch(() => {
});

// node_modules/@polkadot/util-crypto/base32/helpers.js
function createDecode({ coder, ipfs }, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createEncode({ coder, ipfs }) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}
function createIs(validate) {
  return (value, ipfsCompat) => {
    try {
      return validate(value, ipfsCompat);
    } catch {
      return false;
    }
  };
}
function createValidate({ chars: chars2, ipfs, type, withPadding }) {
  return (value, ipfsCompat) => {
    if (typeof value !== "string") {
      throw new Error(`Expected ${type} string input`);
    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {
      if (chars2.includes(value[i])) {
      } else if (withPadding && value[i] === "=") {
        if (i === count - 1) {
        } else if (value[i + 1] === "=") {
        } else {
          throw new Error(`Invalid ${type} padding sequence "${value[i]}${value[i + 1]}" at index ${i}`);
        }
      } else {
        throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
    }
    return true;
  };
}

// node_modules/@polkadot/util-crypto/base58/bs58.js
var config = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: base58,
  ipfs: "z",
  type: "base58"
};
var base58Validate = createValidate(config);
var base58Decode = createDecode(config, base58Validate);
var base58Encode = createEncode(config);
var isBase58 = createIs(base58Validate);

// node_modules/@polkadot/util-crypto/helpers.js
function createAsHex(fn) {
  return (...args) => u8aToHex(fn(...args));
}
function createBitHasher(bitLength, fn) {
  return (data, onlyJs) => fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a) : js[bitLength](u8a);
  };
}

// node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a, u8aToU8a(key), byteLength) : key ? blake2b2(u8a, { dkLen: byteLength, key }) : blake2b2(u8a, { dkLen: byteLength });
}
var blake2AsHex = createAsHex(blake2AsU8a);

// node_modules/@polkadot/util-crypto/address/sshash.js
var SS58_PREFIX = stringToU8a("SS58PRE");
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// node_modules/@polkadot/networks/defaults/genesis.js
var knownGenesis = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  cere: [
    "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  creditcoin3: [
    "0x4436a7d64e363df85e065a894721002a86643283f9707338bf195d360ba2ee71",
    // cc3 mainnet
    "0xfc4ec97a1c1f119c4353aecb4a17c7c0cf7b40d5d660143d8bad9117e9866572",
    // cc3 testnet/drynet
    "0xfc9df99a665f964aed6649f275055e54df5e3420489538ed31d7788f53d11ef6"
    // cc3 devnet
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  dentnet: [
    "0x0313f6a011d128d22f996703cbab05162e2fdc9e031493314fe6db79979c5ca7"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  encointer: [
    "0x7dd99936c1e9e6d1ce7d90eb6f33bea8393b4bf87677d675aa63c9cb3e8c5b5b"
  ],
  enjin: [
    "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  frequency: [
    "0x4a587bf17a404e3572747add7aab7bbe56e805a5479c6c436f07f36fcc8d3ae1"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    // Hydration | HydraDX Parachain
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    // Snakenet Gen3-1
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    // Snakenet Gen3
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    // Snakenet Gen2
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  integritee: [
    "0xcdedc8eadbfa209d3f207bba541e57c3c58a667b05a2e1d1e86353c9000758da",
    // on Kusama
    "0xe13e7af377c64e83f95e0d70d5e5c3c01d697a84538776c5b9bbe0e7d7b6034c"
    // on Polkadot
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    // Kusama CC3,
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    // Kusama CC2
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  liberland: [
    "0x6bd89e052d67a45bb60a9a23e8581053d5e0d619f15cb9865946937e690c42d6"
  ],
  matrixchain: [
    "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
  ],
  mythos: [
    "0xf6ee56e9c5277df5b4ce6ae9983ee88f3cbed27d31beeb98f9f84f997a1ab0b9"
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  peaq: [
    "0xd2a5d385932d1f650dae03ef8e2748983779ee342c614f80854d32b8cd8fa48c"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polimec: [
    "0x7eb9354488318e7549c722669dcbdcdc526f1fef1420e7944667212f3601fdbd"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  quartz: [
    "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vara: [
    "0xfe1b4c55fd4d668101126434206571a7838a8b6b93a6d1b95d607e78e6c53763"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ],
  zeitgeist: [
    "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
  ]
};

// node_modules/@polkadot/networks/defaults/icons.js
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/networks/defaults/ledger.js
var knownLedger = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  bittensor: 354,
  centrifuge: 747,
  composable: 354,
  creditcoin3: 354,
  darwinia: 354,
  dentnet: 734,
  "dock-mainnet": 594,
  edgeware: 523,
  encointer: 434,
  enjin: 1155,
  equilibrium: 99999997,
  frequency: 2091,
  genshiro: 99999996,
  hydradx: 354,
  integritee: 2015,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  liberland: 767,
  matrixchain: 1155,
  mythos: 60,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  peaq: 3338,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polimec: 3344,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  // common-good on Kusama, shares derivation
  statemint: 354,
  // common-good on Polkadot, shares derivation
  ternoa: 995,
  unique: 661,
  vara: 4976,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
};

// node_modules/@polkadot/networks/defaults/testnets.js
var knownTestnet = {
  "": true,
  // this is the default non-network entry
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o) {
  var _a, _b;
  const network = o.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n = o;
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || "substrate";
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && ((_a = o.decimals) == null ? void 0 : _a.length) && ((_b = o.symbols) == null ? void 0 : _b.length)) && o.prefix !== 42;
  return n;
}
function filterSelectable({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/util-crypto/address/defaults.js
var defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({ prefix }) => prefix),
  prefix: 42
};

// node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// node_modules/@polkadot/util-crypto/address/addressToEvm.js
function addressToEvm(address, ignoreChecksum) {
  return decodeAddress(address, ignoreChecksum).subarray(0, 20);
}

// node_modules/@polkadot/util-crypto/address/check.js
function checkAddress(address, prefix) {
  let decoded;
  try {
    decoded = base58Decode(address);
  } catch (error) {
    return [false, error.message];
  }
  const [isValid, , , ss58Decoded] = checkAddressChecksum(decoded);
  if (ss58Decoded !== prefix) {
    return [false, `Prefix mismatch, expected ${prefix}, found ${ss58Decoded}`];
  } else if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
    return [false, "Invalid decoded address length"];
  }
  return [isValid, isValid ? null : "Invalid decoded address checksum"];
}

// node_modules/@polkadot/util-crypto/bn.js
var BN_BE_OPTS = { isLe: false };
var BN_LE_OPTS = { isLe: true };
var BN_LE_16_OPTS = { bitLength: 16, isLe: true };
var BN_BE_32_OPTS = { bitLength: 32, isLe: false };
var BN_LE_32_OPTS = { bitLength: 32, isLe: true };
var BN_BE_256_OPTS = { bitLength: 256, isLe: false };
var BN_LE_256_OPTS = { bitLength: 256, isLe: true };
var BN_LE_512_OPTS = { bitLength: 512, isLe: true };

// node_modules/@polkadot/util-crypto/key/DeriveJunction.js
var RE_NUMBER = /^\d+$/;
var JUNCTION_ID_LEN = 32;
var _chainCode, _isHard;
var _DeriveJunction = class _DeriveJunction {
  constructor() {
    __privateAdd(this, _chainCode, new Uint8Array(32));
    __privateAdd(this, _isHard, false);
  }
  static from(value) {
    const result = new _DeriveJunction();
    const [code, isHard] = value.startsWith("/") ? [value.substring(1), true] : [value, false];
    result.soft(RE_NUMBER.test(code) ? new import_bn.default(code, 10) : code);
    return isHard ? result.harden() : result;
  }
  get chainCode() {
    return __privateGet(this, _chainCode);
  }
  get isHard() {
    return __privateGet(this, _isHard);
  }
  get isSoft() {
    return !__privateGet(this, _isHard);
  }
  hard(value) {
    return this.soft(value).harden();
  }
  harden() {
    __privateSet(this, _isHard, true);
    return this;
  }
  soft(value) {
    if (isNumber(value) || isBn(value) || isBigInt(value)) {
      return this.soft(bnToU8a(value, BN_LE_256_OPTS));
    } else if (isHex(value)) {
      return this.soft(hexToU8a(value));
    } else if (isString(value)) {
      return this.soft(compactAddLength(stringToU8a(value)));
    } else if (value.length > JUNCTION_ID_LEN) {
      return this.soft(blake2AsU8a(value));
    }
    __privateGet(this, _chainCode).fill(0);
    __privateGet(this, _chainCode).set(value, 0);
    return this;
  }
  soften() {
    __privateSet(this, _isHard, false);
    return this;
  }
};
_chainCode = new WeakMap();
_isHard = new WeakMap();
var DeriveJunction = _DeriveJunction;

// node_modules/@polkadot/util-crypto/key/extractPath.js
var RE_JUNCTION = /\/(\/?)([^/]+)/g;
function keyExtractPath(derivePath) {
  const parts = derivePath.match(RE_JUNCTION);
  const path = [];
  let constructed = "";
  if (parts) {
    constructed = parts.join("");
    for (const p of parts) {
      path.push(DeriveJunction.from(p.substring(1)));
    }
  }
  if (constructed !== derivePath) {
    throw new Error(`Re-constructed path "${constructed}" does not match input`);
  }
  return {
    parts,
    path
  };
}

// node_modules/@polkadot/util-crypto/key/extractSuri.js
var RE_CAPTURE = /^((0x[a-fA-F0-9]+|[\p{L}\d]+(?: [\p{L}\d]+)*))((\/\/?[^/]+)*)(\/\/\/(.*))?$/u;
function keyExtractSuri(suri) {
  const normalizedSuri = suri.normalize("NFC");
  const matches = normalizedSuri.match(RE_CAPTURE);
  if (matches === null) {
    throw new Error("Unable to match provided value to a secret URI");
  }
  const [, phrase, , derivePath, , , password] = matches;
  const { path } = keyExtractPath(derivePath);
  return {
    derivePath,
    password,
    path,
    phrase
  };
}

// node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js
var HDKD = compactAddLength(stringToU8a("Secp256k1HDKD"));
function secp256k1DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);
}

// node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
function secp256k1PairFromSeed(seed, onlyJs) {
  if (seed.length !== 32) {
    throw new Error("Expected valid 32-byte private key as a seed");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = secp256k1FromSeed(seed);
    const publicKey = full.slice(32);
    if (u8aEmpty(publicKey)) {
      throw new Error("Invalid publicKey generated from WASM interface");
    }
    return {
      publicKey,
      secretKey: full.slice(0, 32)
    };
  }
  return {
    publicKey: secp256k1.getPublicKey(seed, true),
    secretKey: seed
  };
}

// node_modules/@polkadot/util-crypto/key/hdkdDerive.js
function createSeedDeriveFn(fromSeed, derive) {
  return (keypair, { chainCode, isHard }) => {
    if (!isHard) {
      throw new Error("A soft key was found in the path and is not supported");
    }
    return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));
  };
}

// node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
var keyHdkdEcdsa = createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);

// node_modules/@polkadot/util-crypto/ed25519/deriveHard.js
var HDKD2 = compactAddLength(stringToU8a("Ed25519HDKD"));
function ed25519DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD2, seed, chainCode));
}

// node_modules/@polkadot/util-crypto/random/asU8a.js
function randomAsU8a(length = 32) {
  return getRandomValues(new Uint8Array(length));
}
var randomAsHex = createAsHex(randomAsU8a);

// node_modules/@polkadot/util-crypto/random/asNumber.js
var BN_53 = new import_bn.default(9007199254740991);
function randomAsNumber() {
  return hexToBn(randomAsHex(8)).and(BN_53).toNumber();
}

// node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
function ed25519PairFromSeed(seed, onlyJs) {
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = ed25519KeypairFromSeed(seed);
    return {
      publicKey: full.slice(32),
      secretKey: full.slice(0, 64)
    };
  }
  const publicKey = ed25519.getPublicKey(seed);
  return {
    publicKey,
    secretKey: u8aConcatStrict([seed, publicKey])
  };
}

// node_modules/@polkadot/util-crypto/ed25519/pair/fromRandom.js
function ed25519PairFromRandom() {
  return ed25519PairFromSeed(randomAsU8a());
}

// node_modules/@polkadot/util-crypto/ed25519/pair/fromSecret.js
function ed25519PairFromSecret(secretKey) {
  if (secretKey.length !== 64) {
    throw new Error("Invalid secretKey provided");
  }
  return {
    publicKey: secretKey.slice(32),
    secretKey
  };
}

// node_modules/@polkadot/util-crypto/ed25519/pair/fromString.js
function ed25519PairFromString(value) {
  return ed25519PairFromSeed(blake2AsU8a(stringToU8a(value)));
}

// node_modules/@polkadot/util-crypto/ed25519/sign.js
function ed25519Sign2(message, { publicKey, secretKey }, onlyJs) {
  if (!secretKey) {
    throw new Error("Expected a valid secretKey");
  } else if (!publicKey) {
    throw new Error("Expected a valid publicKey");
  }
  const messageU8a = u8aToU8a(message);
  const privateU8a = secretKey.subarray(0, 32);
  return !hasBigInt || !onlyJs && isReady() ? ed25519Sign(publicKey, privateU8a, messageU8a) : ed25519.sign(messageU8a, privateU8a);
}

// node_modules/@polkadot/util-crypto/ed25519/verify.js
function ed25519Verify2(message, signature, publicKey, onlyJs) {
  const messageU8a = u8aToU8a(message);
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length}, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  try {
    return !hasBigInt || !onlyJs && isReady() ? ed25519Verify(signatureU8a, messageU8a, publicKeyU8a) : ed25519.verify(signatureU8a, messageU8a, publicKeyU8a);
  } catch {
    return false;
  }
}

// node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
var keyHdkdEd25519 = createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);

// node_modules/@noble/curves/esm/abstract/utils.js
var isBytes2 = isBytes;
var bytesToNumberLE2 = bytesToNumberLE;
var numberToBytesLE2 = numberToBytesLE;
var aInRange2 = aInRange;
var bitMask2 = bitMask;

// node_modules/@scure/sr25519/lib/esm/index.js
var _0n2 = BigInt(0);
var _3n = BigInt(3);
function toData(d) {
  if (typeof d === "string")
    return utf8ToBytes(d);
  if (isBytes2(d))
    return d;
  throw new Error("Wrong data");
}
function abytes2(title, b, ...lengths) {
  if (!isBytes2(b))
    throw new Error(`${title}: Uint8Array expected`);
  if (lengths.length && !lengths.includes(b.length))
    throw new Error(`${title}: Uint8Array expected of length ${lengths}, not of length=${b.length}`);
}
function checkU32(title, n) {
  if (!Number.isSafeInteger(n) || n < 0 || n > 4294967295)
    throw new Error(`${title}: wrong u32 integer: ${n}`);
  return n;
}
function cleanBytes(...list) {
  for (const t of list)
    t.fill(0);
}
var EMPTY = Uint8Array.of();
var CURVE_ORDER = ed25519.CURVE.n;
function parseScalar(title, bytes) {
  abytes2(title, bytes, 32);
  const n = bytesToNumberLE2(bytes);
  aInRange2(title, n, _0n2, CURVE_ORDER);
  return n;
}
var modN = (n) => mod(n, CURVE_ORDER);
var STROBE_R = 166;
var Flags = {
  I: 1,
  A: 1 << 1,
  C: 1 << 2,
  T: 1 << 3,
  M: 1 << 4,
  K: 1 << 5
};
var Strobe128 = class _Strobe128 {
  constructor(protocolLabel) {
    this.state = new Uint8Array(200);
    this.pos = 0;
    this.posBegin = 0;
    this.curFlags = 0;
    this.state.set([1, STROBE_R + 2, 1, 0, 1, 96], 0);
    this.state.set(utf8ToBytes("STROBEv1.0.2"), 6);
    this.state32 = u32(this.state);
    this.keccakF1600();
    this.metaAD(protocolLabel, false);
  }
  keccakF1600() {
    keccakP(this.state32);
  }
  runF() {
    this.state[this.pos] ^= this.posBegin;
    this.state[this.pos + 1] ^= 4;
    this.state[STROBE_R + 1] ^= 128;
    this.keccakF1600();
    this.pos = 0;
    this.posBegin = 0;
  }
  // keccak.update()
  absorb(data) {
    for (let i = 0; i < data.length; i++) {
      this.state[this.pos++] ^= data[i];
      if (this.pos === STROBE_R)
        this.runF();
    }
  }
  // keccak.xof()
  squeeze(len) {
    const data = new Uint8Array(len);
    for (let i = 0; i < data.length; i++) {
      data[i] = this.state[this.pos];
      this.state[this.pos++] = 0;
      if (this.pos === STROBE_R)
        this.runF();
    }
    return data;
  }
  overwrite(data) {
    for (let i = 0; i < data.length; i++) {
      this.state[this.pos++] = data[i];
      if (this.pos === STROBE_R)
        this.runF();
    }
  }
  beginOp(flags, more) {
    if (more) {
      if (this.curFlags !== flags) {
        throw new Error(`Continued op with changed flags from ${this.curFlags.toString(2)} to ${flags.toString(2)}`);
      }
      return;
    }
    if ((flags & Flags.T) !== 0)
      throw new Error("T flag is not supported");
    const oldBegin = this.posBegin;
    this.posBegin = this.pos + 1;
    this.curFlags = flags;
    this.absorb(new Uint8Array([oldBegin, flags]));
    const forceF = (flags & (Flags.C | Flags.K)) !== 0;
    if (forceF && this.pos !== 0)
      this.runF();
  }
  // Public API
  metaAD(data, more) {
    this.beginOp(Flags.M | Flags.A, more);
    this.absorb(toData(data));
  }
  AD(data, more) {
    this.beginOp(Flags.A, more);
    this.absorb(toData(data));
  }
  PRF(len, more) {
    this.beginOp(Flags.I | Flags.A | Flags.C, more);
    return this.squeeze(len);
  }
  KEY(data, more) {
    this.beginOp(Flags.A | Flags.C, more);
    this.overwrite(toData(data));
  }
  // Utils
  clone() {
    const n = new _Strobe128("0");
    n.pos = this.pos;
    n.posBegin = this.posBegin;
    n.state.set(this.state);
    n.curFlags = this.curFlags;
    return n;
  }
  clean() {
    this.state.fill(0);
    this.pos = 0;
    this.curFlags = 0;
    this.posBegin = 0;
  }
};
var Merlin = class {
  constructor(label) {
    this.strobe = new Strobe128("Merlin v1.0");
    this.appendMessage("dom-sep", label);
  }
  appendMessage(label, message) {
    this.strobe.metaAD(label, false);
    checkU32("Merlin.appendMessage", message.length);
    this.strobe.metaAD(numberToBytesLE2(message.length, 4), true);
    this.strobe.AD(message, false);
  }
  challengeBytes(label, len) {
    this.strobe.metaAD(label, false);
    checkU32("Merlin.challengeBytes", len);
    this.strobe.metaAD(numberToBytesLE2(len, 4), true);
    return this.strobe.PRF(len, false);
  }
  clean() {
    this.strobe.clean();
  }
};
var SigningContext = class extends Merlin {
  constructor(name, rng = randomBytes) {
    super(name);
    this.rng = rng;
  }
  label(label) {
    this.appendMessage("", label);
  }
  bytes(bytes) {
    this.appendMessage("sign-bytes", bytes);
    return this;
  }
  protoName(label) {
    this.appendMessage("proto-name", label);
  }
  commitPoint(label, point) {
    this.appendMessage(label, point.toRawBytes());
  }
  challengeScalar(label) {
    return modN(bytesToNumberLE2(this.challengeBytes(label, 64)));
  }
  witnessScalar(label, nonceSeeds = []) {
    return modN(bytesToNumberLE2(this.witnessBytes(label, 64, nonceSeeds)));
  }
  witnessBytes(label, len, nonceSeeds = []) {
    checkU32("SigningContext.witnessBytes", len);
    const strobeRng = this.strobe.clone();
    for (const ns of nonceSeeds) {
      strobeRng.metaAD(label, false);
      checkU32("SigningContext.witnessBytes nonce length", ns.length);
      strobeRng.metaAD(numberToBytesLE2(ns.length, 4), true);
      strobeRng.KEY(ns, false);
    }
    const random = this.rng(32);
    strobeRng.metaAD("rng", false);
    strobeRng.KEY(random, false);
    strobeRng.metaAD(numberToBytesLE2(len, 4), false);
    return strobeRng.PRF(len, false);
  }
};
var MASK = bitMask2(256);
var encodeScalar = (n) => numberToBytesLE2(n << _3n & MASK, 32);
var decodeScalar = (n) => bytesToNumberLE2(n) >> _3n;
function getPublicKey(secretKey) {
  abytes2("secretKey", secretKey, 64);
  const scalar = decodeScalar(secretKey.subarray(0, 32));
  return RistrettoPoint.BASE.multiply(scalar).toRawBytes();
}
function secretFromSeed(seed) {
  abytes2("seed", seed, 32);
  const r = sha5122(seed);
  r[0] &= 248;
  r[31] &= 63;
  r[31] |= 64;
  const key = encodeScalar(decodeScalar(r.subarray(0, 32)));
  const nonce = r.subarray(32, 64);
  const res = concatBytes(key, nonce);
  cleanBytes(key, nonce, r);
  return res;
}
var SUBSTRATE_CONTEXT = utf8ToBytes("substrate");
function sign(secretKey, message, rng = randomBytes) {
  abytes2("message", message);
  abytes2("secretKey", secretKey, 64);
  const t = new SigningContext("SigningContext", rng);
  t.label(SUBSTRATE_CONTEXT);
  t.bytes(message);
  const keyScalar = decodeScalar(secretKey.subarray(0, 32));
  const nonce = secretKey.subarray(32, 64);
  const pubPoint = RistrettoPoint.fromHex(getPublicKey(secretKey));
  t.protoName("Schnorr-sig");
  t.commitPoint("sign:pk", pubPoint);
  const r = t.witnessScalar("signing", [nonce]);
  const R = RistrettoPoint.BASE.multiply(r);
  t.commitPoint("sign:R", R);
  const k = t.challengeScalar("sign:c");
  const s = modN(k * keyScalar + r);
  const res = concatBytes(R.toRawBytes(), numberToBytesLE2(s, 32));
  res[63] |= 128;
  t.clean();
  return res;
}
function verify(message, signature, publicKey) {
  abytes2("message", message);
  abytes2("signature", signature, 64);
  abytes2("publicKey", publicKey, 32);
  if ((signature[63] & 128) === 0)
    throw new Error("Schnorrkel marker missing");
  const sBytes = Uint8Array.from(signature.subarray(32, 64));
  sBytes[31] &= 127;
  const R = RistrettoPoint.fromHex(signature.subarray(0, 32));
  const s = bytesToNumberLE2(sBytes);
  aInRange2("s", s, _0n2, CURVE_ORDER);
  const t = new SigningContext("SigningContext");
  t.label(SUBSTRATE_CONTEXT);
  t.bytes(message);
  const pubPoint = RistrettoPoint.fromHex(publicKey);
  if (pubPoint.equals(RistrettoPoint.ZERO))
    return false;
  t.protoName("Schnorr-sig");
  t.commitPoint("sign:pk", pubPoint);
  t.commitPoint("sign:R", R);
  const k = t.challengeScalar("sign:c");
  const sP = RistrettoPoint.BASE.multiply(s);
  const RR = pubPoint.negate().multiply(k).add(sP);
  t.clean();
  cleanBytes(sBytes);
  return RR.equals(R);
}
function getSharedSecret(secretKey, publicKey) {
  abytes2("secretKey", secretKey, 64);
  abytes2("publicKey", publicKey, 32);
  const keyScalar = decodeScalar(secretKey.subarray(0, 32));
  const pubPoint = RistrettoPoint.fromHex(publicKey);
  if (pubPoint.equals(RistrettoPoint.ZERO))
    throw new Error("wrong public key (infinity)");
  return pubPoint.multiply(keyScalar).toRawBytes();
}
var HDKD3 = {
  secretSoft(secretKey, chainCode, rng = randomBytes) {
    abytes2("secretKey", secretKey, 64);
    abytes2("chainCode", chainCode, 32);
    const masterScalar = decodeScalar(secretKey.subarray(0, 32));
    const masterNonce = secretKey.subarray(32, 64);
    const pubPoint = RistrettoPoint.fromHex(getPublicKey(secretKey));
    const t = new SigningContext("SchnorrRistrettoHDKD", rng);
    t.bytes(EMPTY);
    t.appendMessage("chain-code", chainCode);
    t.commitPoint("public-key", pubPoint);
    const scalar = t.challengeScalar("HDKD-scalar");
    const hdkdChainCode = t.challengeBytes("HDKD-chaincode", 32);
    const nonceSeed = concatBytes(numberToBytesLE2(masterScalar, 32), masterNonce);
    const nonce = t.witnessBytes("HDKD-nonce", 32, [masterNonce, nonceSeed]);
    const key = encodeScalar(modN(masterScalar + scalar));
    const res = concatBytes(key, nonce);
    cleanBytes(key, nonce, nonceSeed, hdkdChainCode);
    t.clean();
    return res;
  },
  publicSoft(publicKey, chainCode) {
    abytes2("publicKey", publicKey, 32);
    abytes2("chainCode", chainCode, 32);
    const pubPoint = RistrettoPoint.fromHex(publicKey);
    const t = new SigningContext("SchnorrRistrettoHDKD");
    t.bytes(EMPTY);
    t.appendMessage("chain-code", chainCode);
    t.commitPoint("public-key", pubPoint);
    const scalar = t.challengeScalar("HDKD-scalar");
    t.challengeBytes("HDKD-chaincode", 32);
    t.clean();
    return pubPoint.add(RistrettoPoint.BASE.multiply(scalar)).toRawBytes();
  },
  secretHard(secretKey, chainCode) {
    abytes2("secretKey", secretKey, 64);
    abytes2("chainCode", chainCode, 32);
    const key = numberToBytesLE2(decodeScalar(secretKey.subarray(0, 32)), 32);
    const t = new SigningContext("SchnorrRistrettoHDKD");
    t.bytes(EMPTY);
    t.appendMessage("chain-code", chainCode);
    t.appendMessage("secret-key", key);
    const msk = t.challengeBytes("HDKD-hard", 32);
    const hdkdChainCode = t.challengeBytes("HDKD-chaincode", 32);
    t.clean();
    const res = secretFromSeed(msk);
    cleanBytes(key, msk, hdkdChainCode);
    t.clean();
    return res;
  }
};
var dleq = {
  proove(keyScalar, nonce, pubPoint, t, input, output) {
    t.protoName("DLEQProof");
    t.commitPoint("vrf:h", input);
    const r = t.witnessScalar(`proving${"\0"}0`, [nonce]);
    const R = RistrettoPoint.BASE.multiply(r);
    t.commitPoint("vrf:R=g^r", R);
    const Hr = input.multiply(r);
    t.commitPoint("vrf:h^r", Hr);
    t.commitPoint("vrf:pk", pubPoint);
    t.commitPoint("vrf:h^sk", output);
    const c = t.challengeScalar("prove");
    const s = modN(r - c * keyScalar);
    return { proof: { c, s }, proofBatchable: { R, Hr, s } };
  },
  verify(pubPoint, t, input, output, proof) {
    if (pubPoint.equals(RistrettoPoint.ZERO))
      return false;
    t.protoName("DLEQProof");
    t.commitPoint("vrf:h", input);
    const R = pubPoint.multiply(proof.c).add(RistrettoPoint.BASE.multiply(proof.s));
    t.commitPoint("vrf:R=g^r", R);
    const Hr = output.multiply(proof.c).add(input.multiply(proof.s));
    t.commitPoint("vrf:h^r", Hr);
    t.commitPoint("vrf:pk", pubPoint);
    t.commitPoint("vrf:h^sk", output);
    const realC = t.challengeScalar("prove");
    if (proof.c === realC)
      return { R, Hr, s: proof.s };
    return false;
  }
};
function initVRF(ctx, msg, extra, pubPoint, rng = randomBytes) {
  const t = new SigningContext("SigningContext", rng);
  t.label(ctx);
  t.bytes(msg);
  t.commitPoint("vrf-nm-pk", pubPoint);
  const hash = t.challengeBytes("VRFHash", 64);
  const input = RistrettoPoint.hashToCurve(hash);
  const transcript = new SigningContext("VRF", rng);
  if (extra.length)
    transcript.label(extra);
  t.clean();
  cleanBytes(hash);
  return { input, t: transcript };
}
var vrf = {
  sign(msg, secretKey, ctx = EMPTY, extra = EMPTY, rng = randomBytes) {
    abytes2("msg", msg);
    abytes2("secretKey", secretKey, 64);
    abytes2("ctx", ctx);
    abytes2("extra", extra);
    const keyScalar = decodeScalar(secretKey.subarray(0, 32));
    const nonce = secretKey.subarray(32, 64);
    const pubPoint = RistrettoPoint.fromHex(getPublicKey(secretKey));
    const { input, t } = initVRF(ctx, msg, extra, pubPoint, rng);
    const output = input.multiply(keyScalar);
    const p = { input, output };
    const { proof } = dleq.proove(keyScalar, nonce, pubPoint, t, input, output);
    const cBytes = numberToBytesLE2(proof.c, 32);
    const sBytes = numberToBytesLE2(proof.s, 32);
    const res = concatBytes(p.output.toRawBytes(), cBytes, sBytes);
    cleanBytes(nonce, cBytes, sBytes);
    return res;
  },
  verify(msg, signature, publicKey, ctx = EMPTY, extra = EMPTY, rng = randomBytes) {
    abytes2("msg", msg);
    abytes2("signature", signature, 96);
    abytes2("pubkey", publicKey, 32);
    abytes2("ctx", ctx);
    abytes2("extra", extra);
    const pubPoint = RistrettoPoint.fromHex(publicKey);
    if (pubPoint.equals(RistrettoPoint.ZERO))
      return false;
    const proof = {
      c: parseScalar("signature.c", signature.subarray(32, 64)),
      s: parseScalar("signature.s", signature.subarray(64, 96))
    };
    const { input, t } = initVRF(ctx, msg, extra, pubPoint, rng);
    const output = RistrettoPoint.fromHex(signature.subarray(0, 32));
    if (output.equals(RistrettoPoint.ZERO))
      throw new Error("vrf.verify: wrong output point (identity)");
    const proofBatchable = dleq.verify(pubPoint, t, input, output, proof);
    return proofBatchable === false ? false : true;
  }
};

// node_modules/@polkadot/util-crypto/sr25519/derive.js
function createDeriveFn(derive) {
  return (keypair, chainCode) => {
    if (!isU8a(chainCode) || chainCode.length !== 32) {
      throw new Error("Invalid chainCode passed to derive");
    }
    const secretKey = derive(keypair.secretKey, chainCode);
    const publicKey = getPublicKey(secretKey);
    return { publicKey, secretKey };
  };
}

// node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
var sr25519DeriveHard = createDeriveFn(HDKD3.secretHard);

// node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js
var sr25519DeriveSoft = createDeriveFn(HDKD3.secretSoft);

// node_modules/@polkadot/util-crypto/key/hdkdSr25519.js
function keyHdkdSr25519(keypair, { chainCode, isSoft }) {
  return isSoft ? sr25519DeriveSoft(keypair, chainCode) : sr25519DeriveHard(keypair, chainCode);
}

// node_modules/@polkadot/util-crypto/key/fromPath.js
var generators = {
  ecdsa: keyHdkdEcdsa,
  ed25519: keyHdkdEd25519,
  // FIXME This is Substrate-compatible, not Ethereum-compatible
  ethereum: keyHdkdEcdsa,
  sr25519: keyHdkdSr25519
};
function keyFromPath(pair, path, type) {
  const keyHdkd = generators[type];
  let result = pair;
  for (const junction of path) {
    result = keyHdkd(result, junction);
  }
  return result;
}

// node_modules/@polkadot/util-crypto/sr25519/agreement.js
function sr25519Agreement(secretKey, publicKey) {
  const secretKeyU8a = u8aToU8a(secretKey);
  const publicKeyU8a = u8aToU8a(publicKey);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (secretKeyU8a.length !== 64) {
    throw new Error(`Invalid secretKey, received ${secretKeyU8a.length} bytes, expected 64`);
  }
  return getSharedSecret(secretKeyU8a, publicKeyU8a);
}

// node_modules/@polkadot/util-crypto/sr25519/derivePublic.js
function sr25519DerivePublic(publicKey, chainCode) {
  const publicKeyU8a = u8aToU8a(publicKey);
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  } else if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  }
  return HDKD3.publicSoft(publicKeyU8a, chainCode);
}

// node_modules/@polkadot/util-crypto/sr25519/pair/fromSeed.js
function sr25519PairFromSeed(seed) {
  const seedU8a = u8aToU8a(seed);
  if (seedU8a.length !== 32) {
    throw new Error(`Expected a seed matching 32 bytes, found ${seedU8a.length}`);
  }
  const sec = secretFromSeed(seedU8a);
  const pub = getPublicKey(sec);
  return {
    publicKey: pub,
    secretKey: sec
  };
}

// node_modules/@polkadot/util-crypto/sr25519/sign.js
function sr25519Sign(message, { publicKey, secretKey }) {
  if ((publicKey == null ? void 0 : publicKey.length) !== 32) {
    throw new Error("Expected a valid publicKey, 32-bytes");
  } else if ((secretKey == null ? void 0 : secretKey.length) !== 64) {
    throw new Error("Expected a valid secretKey, 64-bytes");
  }
  return sign(secretKey, u8aToU8a(message));
}

// node_modules/@polkadot/util-crypto/sr25519/verify.js
function sr25519Verify(message, signature, publicKey) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const signatureU8a = u8aToU8a(signature);
  if (publicKeyU8a.length !== 32) {
    throw new Error(`Invalid publicKey, received ${publicKeyU8a.length} bytes, expected 32`);
  } else if (signatureU8a.length !== 64) {
    throw new Error(`Invalid signature, received ${signatureU8a.length} bytes, expected 64`);
  }
  return verify(u8aToU8a(message), signatureU8a, publicKeyU8a);
}

// node_modules/@polkadot/util-crypto/sr25519/vrfSign.js
var EMPTY_U8A = new Uint8Array();
function sr25519VrfSign(message, { secretKey }, context = EMPTY_U8A, extra = EMPTY_U8A) {
  if ((secretKey == null ? void 0 : secretKey.length) !== 64) {
    throw new Error("Invalid secretKey, expected 64-bytes");
  }
  return vrf.sign(u8aToU8a(message), secretKey, u8aToU8a(context), u8aToU8a(extra), randomBytes);
}

// node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js
var EMPTY_U8A2 = new Uint8Array();
function sr25519VrfVerify(message, signOutput, publicKey, context = EMPTY_U8A2, extra = EMPTY_U8A2) {
  const publicKeyU8a = u8aToU8a(publicKey);
  const proofU8a = u8aToU8a(signOutput);
  if (publicKeyU8a.length !== 32) {
    throw new Error("Invalid publicKey, expected 32-bytes");
  } else if (proofU8a.length !== 96) {
    throw new Error("Invalid vrfSign output, expected 96 bytes");
  }
  return vrf.verify(u8aToU8a(message), proofU8a, publicKeyU8a, u8aToU8a(context), u8aToU8a(extra));
}

// node_modules/@polkadot/util-crypto/address/encode.js
function encodeAddress(key, ss58Format = defaults.prefix) {
  const u8a = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 && !ss58Exceptions.includes(ss58Format) || [46, 47].includes(ss58Format)) {
    throw new Error("Out of range ss58Format specified");
  } else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(", ")}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  ], u8a);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}
var ss58Exceptions = [29972];

// node_modules/@polkadot/util-crypto/address/derive.js
function filterHard({ isHard }) {
  return isHard;
}
function deriveAddress(who, suri, ss58Format) {
  const { path } = keyExtractPath(suri);
  if (!path.length || path.every(filterHard)) {
    throw new Error("Expected suri to contain a combination of non-hard paths");
  }
  let publicKey = decodeAddress(who);
  for (const { chainCode } of path) {
    publicKey = sr25519DerivePublic(publicKey, chainCode);
  }
  return encodeAddress(publicKey, ss58Format);
}

// node_modules/@polkadot/util-crypto/address/keyDerived.js
var PREFIX = stringToU8a("modlpy/utilisuba");
function createKeyDerived(who, index) {
  return blake2AsU8a(u8aConcat(PREFIX, decodeAddress(who), bnToU8a(index, BN_LE_16_OPTS)));
}

// node_modules/@polkadot/util-crypto/address/encodeDerived.js
function encodeDerivedAddress(who, index, ss58Format) {
  return encodeAddress(createKeyDerived(decodeAddress(who), index), ss58Format);
}

// node_modules/@polkadot/util-crypto/address/util.js
function addressToU8a(who) {
  return decodeAddress(who);
}

// node_modules/@polkadot/util-crypto/address/keyMulti.js
var PREFIX2 = stringToU8a("modlpy/utilisuba");
function createKeyMulti(who, threshold) {
  return blake2AsU8a(u8aConcat(PREFIX2, compactToU8a(who.length), ...u8aSorted(who.map(addressToU8a)), bnToU8a(threshold, BN_LE_16_OPTS)));
}

// node_modules/@polkadot/util-crypto/address/encodeMulti.js
function encodeMultiAddress(who, threshold, ss58Format) {
  return encodeAddress(createKeyMulti(who, threshold), ss58Format);
}

// node_modules/@polkadot/util-crypto/address/eq.js
function addressEq(a, b) {
  return u8aEq(decodeAddress(a), decodeAddress(b));
}

// node_modules/@polkadot/util-crypto/keccak/asU8a.js
var keccakAsU8a = createDualHasher({ 256: keccak256, 512: keccak512 }, { 256: keccak_256, 512: keccak_512 });
var keccak256AsU8a = createBitHasher(256, keccakAsU8a);
var keccak512AsU8a = createBitHasher(512, keccakAsU8a);
var keccakAsHex = createAsHex(keccakAsU8a);

// node_modules/@polkadot/util-crypto/secp256k1/hasher.js
function hasher(hashType, data, onlyJs) {
  return hashType === "keccak" ? keccakAsU8a(data, void 0, onlyJs) : blake2AsU8a(data, void 0, void 0, onlyJs);
}

// node_modules/@polkadot/util-crypto/address/evmToAddress.js
function evmToAddress(evmAddress, ss58Format, hashType = "blake2") {
  const message = u8aConcat("evm:", evmAddress);
  if (message.length !== 24) {
    throw new Error(`Converting ${evmAddress}: Invalid evm address length`);
  }
  return encodeAddress(hasher(hashType, message), ss58Format);
}

// node_modules/@polkadot/util-crypto/address/validate.js
function validateAddress(encoded, ignoreChecksum, ss58Format) {
  return !!decodeAddress(encoded, ignoreChecksum, ss58Format);
}

// node_modules/@polkadot/util-crypto/address/is.js
function isAddress(address, ignoreChecksum, ss58Format) {
  try {
    return validateAddress(address, ignoreChecksum, ss58Format);
  } catch {
    return false;
  }
}

// node_modules/@polkadot/util-crypto/address/sort.js
function sortAddresses(addresses, ss58Format) {
  const u8aToAddress = (u8a) => encodeAddress(u8a, ss58Format);
  return u8aSorted(addresses.map(addressToU8a)).map(u8aToAddress);
}

// node_modules/@polkadot/util-crypto/address/setSS58Format.js
var l = logger("setSS58Format");
function setSS58Format(prefix) {
  l.warn("Global setting of the ss58Format is deprecated and not recommended. Set format on the keyring (if used) or as part of the address encode function");
  defaults.prefix = prefix;
}

// node_modules/@polkadot/util-crypto/base32/bs32.js
var chars = "abcdefghijklmnopqrstuvwxyz234567";
var config2 = {
  chars,
  coder: utils.chain(
    // We define our own chain, the default base32 has padding
    utils.radix2(5),
    utils.alphabet(chars),
    {
      decode: (input) => input.split(""),
      encode: (input) => input.join("")
    }
  ),
  ipfs: "b",
  type: "base32"
};
var base32Validate = createValidate(config2);
var isBase32 = createIs(base32Validate);
var base32Decode = createDecode(config2, base32Validate);
var base32Encode = createEncode(config2);

// node_modules/@polkadot/util-crypto/base64/bs64.js
var config3 = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  coder: base64,
  type: "base64",
  withPadding: true
};
var base64Validate = createValidate(config3);
var isBase64 = createIs(base64Validate);
var base64Decode = createDecode(config3, base64Validate);
var base64Encode = createEncode(config3);

// node_modules/@polkadot/util-crypto/base64/pad.js
function base64Pad(value) {
  return value.padEnd(value.length + value.length % 4, "=");
}

// node_modules/@polkadot/util-crypto/base64/trim.js
function base64Trim(value) {
  while (value.length && value.endsWith("=")) {
    value = value.slice(0, -1);
  }
  return value;
}

// node_modules/@polkadot/util-crypto/secp256k1/compress.js
function secp256k1Compress2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 33) {
    return publicKey;
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress(publicKey) : secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(true);
}

// node_modules/@polkadot/util-crypto/secp256k1/expand.js
function secp256k1Expand2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 65) {
    return publicKey.subarray(1);
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand(publicKey).subarray(1);
  }
  const { px, py } = secp256k1.ProjectivePoint.fromHex(publicKey);
  return u8aConcat(bnToU8a(px, BN_BE_256_OPTS), bnToU8a(py, BN_BE_256_OPTS));
}

// node_modules/@polkadot/util-crypto/secp256k1/recover.js
function secp256k1Recover2(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover(msg, sig, recovery) : secp256k1.Signature.fromCompact(sig).addRecoveryBit(recovery).recoverPublicKey(msg).toRawBytes();
  if (!publicKey) {
    throw new Error("Unable to recover publicKey from signature");
  }
  return hashType === "keccak" ? secp256k1Expand2(publicKey, onlyJs) : secp256k1Compress2(publicKey, onlyJs);
}

// node_modules/@polkadot/util-crypto/secp256k1/sign.js
function secp256k1Sign2(message, { secretKey }, hashType = "blake2", onlyJs) {
  if ((secretKey == null ? void 0 : secretKey.length) !== 32) {
    throw new Error("Expected valid secp256k1 secretKey, 32-bytes");
  }
  const data = hasher(hashType, message, onlyJs);
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Sign(data, secretKey);
  }
  const signature = secp256k1.sign(data, secretKey, { lowS: true });
  return u8aConcat(bnToU8a(signature.r, BN_BE_256_OPTS), bnToU8a(signature.s, BN_BE_256_OPTS), new Uint8Array([signature.recovery || 0]));
}

// node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js
var N = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
var N_BI = BigInt2(`0x${N}`);
var N_BN = new import_bn.default(N, "hex");
function addBi(seckey, tweak) {
  let res = u8aToBigInt(tweak, BN_BE_OPTS);
  if (res >= N_BI) {
    throw new Error("Tweak parameter is out of range");
  }
  res += u8aToBigInt(seckey, BN_BE_OPTS);
  if (res >= N_BI) {
    res -= N_BI;
  }
  if (res === _0n) {
    throw new Error("Invalid resulting private key");
  }
  return nToU8a(res, BN_BE_256_OPTS);
}
function addBn(seckey, tweak) {
  const res = new import_bn.default(tweak);
  if (res.cmp(N_BN) >= 0) {
    throw new Error("Tweak parameter is out of range");
  }
  res.iadd(new import_bn.default(seckey));
  if (res.cmp(N_BN) >= 0) {
    res.isub(N_BN);
  }
  if (res.isZero()) {
    throw new Error("Invalid resulting private key");
  }
  return bnToU8a(res, BN_BE_256_OPTS);
}
function secp256k1PrivateKeyTweakAdd(seckey, tweak, onlyBn) {
  if (!isU8a(seckey) || seckey.length !== 32) {
    throw new Error("Expected seckey to be an Uint8Array with length 32");
  } else if (!isU8a(tweak) || tweak.length !== 32) {
    throw new Error("Expected tweak to be an Uint8Array with length 32");
  }
  return !hasBigInt || onlyBn ? addBn(seckey, tweak) : addBi(seckey, tweak);
}

// node_modules/@polkadot/util-crypto/secp256k1/verify.js
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature);
  if (sig.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);
  }
  const publicKey = secp256k1Recover2(hasher(hashType, msgHash), sig, sig[64], hashType, onlyJs);
  const signerAddr = hasher(hashType, publicKey, onlyJs);
  const inputAddr = u8aToU8a(address);
  return u8aEq(publicKey, inputAddr) || (hashType === "keccak" ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}

// node_modules/@polkadot/util-crypto/ethereum/encode.js
function getH160(u8a) {
  if ([33, 65].includes(u8a.length)) {
    u8a = keccakAsU8a(secp256k1Expand2(u8a));
  }
  return u8a.slice(-20);
}
function ethereumEncode(addressOrPublic) {
  if (!addressOrPublic) {
    return "0x";
  }
  const u8aAddress = u8aToU8a(addressOrPublic);
  if (![20, 32, 33, 65].includes(u8aAddress.length)) {
    throw new Error(`Invalid address or publicKey provided, received ${u8aAddress.length} bytes input`);
  }
  const address = u8aToHex(getH160(u8aAddress), -1, false);
  const hash = u8aToHex(keccakAsU8a(address), -1, false);
  let result = "";
  for (let i = 0; i < 40; i++) {
    result = `${result}${parseInt(hash[i], 16) > 7 ? address[i].toUpperCase() : address[i]}`;
  }
  return `0x${result}`;
}

// node_modules/@polkadot/util-crypto/ethereum/isChecksum.js
function isInvalidChar(char, byte) {
  return char !== (byte > 7 ? char.toUpperCase() : char.toLowerCase());
}
function isEthereumChecksum(_address) {
  const address = _address.replace("0x", "");
  const hash = u8aToHex(keccakAsU8a(address.toLowerCase()), -1, false);
  for (let i = 0; i < 40; i++) {
    if (isInvalidChar(address[i], parseInt(hash[i], 16))) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util-crypto/ethereum/isAddress.js
function isEthereumAddress(address) {
  if (!address || address.length !== 42 || !isHex(address)) {
    return false;
  } else if (/^(0x)?[0-9a-f]{40}$/.test(address) || /^(0x)?[0-9A-F]{40}$/.test(address)) {
    return true;
  }
  return isEthereumChecksum(address);
}

// node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js
var JS_HASH = {
  256: sha2562,
  512: sha5122
};
var WA_MHAC = {
  256: hmacSha256,
  512: hmacSha512
};
function createSha(bitLength) {
  return (key, data, onlyJs) => hmacShaAsU8a(key, data, bitLength, onlyJs);
}
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
  const u8aKey = u8aToU8a(key);
  return !hasBigInt || !onlyJs && isReady() ? WA_MHAC[bitLength](u8aKey, data) : hmac(JS_HASH[bitLength], u8aKey, data);
}
var hmacSha256AsU8a = createSha(256);
var hmacSha512AsU8a = createSha(512);

// node_modules/@polkadot/util-crypto/hd/validatePath.js
var HARDENED = 2147483648;
function hdValidatePath(path) {
  if (!path.startsWith("m/")) {
    return false;
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    const n = /^\d+'?$/.test(p) ? parseInt(p.replace(/'$/, ""), 10) : Number.NaN;
    if (isNaN(n) || n >= HARDENED || n < 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/util-crypto/hd/ethereum/index.js
var MASTER_SECRET = stringToU8a("Bitcoin seed");
function createCoded(secretKey, chainCode) {
  return {
    chainCode,
    publicKey: secp256k1PairFromSeed(secretKey).publicKey,
    secretKey
  };
}
function deriveChild(hd, index) {
  const indexBuffer = bnToU8a(index, BN_BE_32_OPTS);
  const data = index >= HARDENED ? u8aConcat(new Uint8Array(1), hd.secretKey, indexBuffer) : u8aConcat(hd.publicKey, indexBuffer);
  try {
    const I = hmacShaAsU8a(hd.chainCode, data, 512);
    return createCoded(secp256k1PrivateKeyTweakAdd(hd.secretKey, I.slice(0, 32)), I.slice(32));
  } catch {
    return deriveChild(hd, index + 1);
  }
}
function hdEthereum(seed, path = "") {
  const I = hmacShaAsU8a(MASTER_SECRET, seed, 512);
  let hd = createCoded(I.slice(0, 32), I.slice(32));
  if (!path || path === "m" || path === "M" || path === "m'" || path === "M'") {
    return hd;
  }
  if (!hdValidatePath(path)) {
    throw new Error("Invalid derivation path");
  }
  const parts = path.split("/").slice(1);
  for (const p of parts) {
    hd = deriveChild(hd, parseInt(p, 10) + (p.length > 1 && p.endsWith("'") ? HARDENED : 0));
  }
  return hd;
}

// node_modules/@polkadot/util-crypto/pbkdf2/encode.js
function pbkdf2Encode(passphrase, salt = randomAsU8a(), rounds = 2048, onlyJs) {
  const u8aPass = u8aToU8a(passphrase);
  const u8aSalt = u8aToU8a(salt);
  return {
    password: !hasBigInt || !onlyJs && isReady() ? pbkdf2(u8aPass, u8aSalt, rounds) : pbkdf22(sha5122, u8aPass, u8aSalt, { c: rounds, dkLen: 64 }),
    rounds,
    salt
  };
}

// node_modules/@polkadot/util-crypto/sha/asU8a.js
var shaAsU8a = createDualHasher({ 256: sha256, 512: sha512 }, { 256: sha2562, 512: sha5122 });
var sha256AsU8a = createBitHasher(256, shaAsU8a);
var sha512AsU8a = createBitHasher(512, shaAsU8a);

// node_modules/@polkadot/util-crypto/mnemonic/wordlists/en.js
var en_default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");

// node_modules/@polkadot/util-crypto/mnemonic/bip39.js
var INVALID_MNEMONIC = "Invalid mnemonic";
var INVALID_ENTROPY = "Invalid entropy";
var INVALID_CHECKSUM = "Invalid mnemonic checksum";
function normalize(str) {
  return (str || "").normalize("NFKD");
}
function binaryToByte(bin) {
  return parseInt(bin, 2);
}
function bytesToBinary(bytes) {
  return bytes.map((x) => x.toString(2).padStart(8, "0")).join("");
}
function deriveChecksumBits(entropyBuffer) {
  return bytesToBinary(Array.from(sha256AsU8a(entropyBuffer))).slice(0, entropyBuffer.length * 8 / 32);
}
function mnemonicToSeedSync(mnemonic, password) {
  return pbkdf2Encode(stringToU8a(normalize(mnemonic)), stringToU8a(`mnemonic${normalize(password)}`)).password;
}
function mnemonicToEntropy(mnemonic, wordlist = en_default) {
  const words = normalize(mnemonic).split(" ");
  if (words.length % 3 !== 0) {
    throw new Error(INVALID_MNEMONIC);
  }
  const bits = words.map((word) => {
    const index = wordlist.indexOf(word);
    if (index === -1) {
      throw new Error(INVALID_MNEMONIC);
    }
    return index.toString(2).padStart(11, "0");
  }).join("");
  const dividerIndex = Math.floor(bits.length / 33) * 32;
  const entropyBits = bits.slice(0, dividerIndex);
  const checksumBits = bits.slice(dividerIndex);
  const matched = entropyBits.match(/(.{1,8})/g);
  const entropyBytes = matched == null ? void 0 : matched.map(binaryToByte);
  if (!entropyBytes || entropyBytes.length % 4 !== 0 || entropyBytes.length < 16 || entropyBytes.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  const entropy = u8aToU8a(entropyBytes);
  if (deriveChecksumBits(entropy) !== checksumBits) {
    throw new Error(INVALID_CHECKSUM);
  }
  return entropy;
}
function entropyToMnemonic(entropy, wordlist = en_default) {
  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error(INVALID_ENTROPY);
  }
  const matched = `${bytesToBinary(Array.from(entropy))}${deriveChecksumBits(entropy)}`.match(/(.{1,11})/g);
  const mapped = matched == null ? void 0 : matched.map((b) => wordlist[binaryToByte(b)]);
  if (!mapped || mapped.length < 12) {
    throw new Error("Unable to map entropy to mnemonic");
  }
  return mapped.join(" ");
}
function generateMnemonic(numWords, wordlist) {
  return entropyToMnemonic(randomAsU8a(numWords / 3 * 4), wordlist);
}
function validateMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
  } catch {
    return false;
  }
  return true;
}

// node_modules/@polkadot/util-crypto/mnemonic/generate.js
function mnemonicGenerate(numWords = 12, wordlist, onlyJs) {
  return !hasBigInt || !wordlist && !onlyJs && isReady() ? bip39Generate(numWords) : generateMnemonic(numWords, wordlist);
}

// node_modules/@polkadot/util-crypto/mnemonic/toEntropy.js
function mnemonicToEntropy2(mnemonic, wordlist, onlyJs) {
  return !hasBigInt || !wordlist && !onlyJs && isReady() ? bip39ToEntropy(mnemonic) : mnemonicToEntropy(mnemonic, wordlist);
}

// node_modules/@polkadot/util-crypto/mnemonic/validate.js
function mnemonicValidate(mnemonic, wordlist, onlyJs) {
  return !hasBigInt || !wordlist && !onlyJs && isReady() ? bip39Validate(mnemonic) : validateMnemonic(mnemonic, wordlist);
}

// node_modules/@polkadot/util-crypto/mnemonic/toLegacySeed.js
function mnemonicToLegacySeed(mnemonic, password = "", onlyJs, byteLength = 32) {
  if (!mnemonicValidate(mnemonic)) {
    throw new Error("Invalid bip39 mnemonic specified");
  } else if (![32, 64].includes(byteLength)) {
    throw new Error(`Invalid seed length ${byteLength}, expected 32 or 64`);
  }
  return byteLength === 32 ? !hasBigInt || !onlyJs && isReady() ? bip39ToSeed(mnemonic, password) : mnemonicToSeedSync(mnemonic, password).subarray(0, 32) : mnemonicToSeedSync(mnemonic, password);
}

// node_modules/@polkadot/util-crypto/mnemonic/toMiniSecret.js
function mnemonicToMiniSecret(mnemonic, password = "", wordlist, onlyJs) {
  if (!mnemonicValidate(mnemonic, wordlist, onlyJs)) {
    throw new Error("Invalid bip39 mnemonic specified");
  } else if (!wordlist && !onlyJs && isReady()) {
    return bip39ToMiniSecret(mnemonic, password);
  }
  const entropy = mnemonicToEntropy2(mnemonic, wordlist);
  const salt = stringToU8a(`mnemonic${password}`);
  return pbkdf2Encode(entropy, salt).password.slice(0, 32);
}

// node_modules/@polkadot/util-crypto/hd/ledger/derivePrivate.js
function ledgerDerivePrivate(xprv, index) {
  const kl = xprv.subarray(0, 32);
  const kr = xprv.subarray(32, 64);
  const cc = xprv.subarray(64, 96);
  const data = u8aConcat([0], kl, kr, bnToU8a(index, BN_LE_32_OPTS));
  const z = hmacShaAsU8a(cc, data, 512);
  data[0] = 1;
  return u8aConcat(bnToU8a(u8aToBn(kl, BN_LE_OPTS).iadd(u8aToBn(z.subarray(0, 28), BN_LE_OPTS).imul(BN_EIGHT)), BN_LE_512_OPTS).subarray(0, 32), bnToU8a(u8aToBn(kr, BN_LE_OPTS).iadd(u8aToBn(z.subarray(32, 64), BN_LE_OPTS)), BN_LE_512_OPTS).subarray(0, 32), hmacShaAsU8a(cc, data, 512).subarray(32, 64));
}

// node_modules/@polkadot/util-crypto/hd/ledger/master.js
var ED25519_CRYPTO = "ed25519 seed";
function ledgerMaster(mnemonic, password) {
  const seed = mnemonicToSeedSync(mnemonic, password);
  const chainCode = hmacShaAsU8a(ED25519_CRYPTO, new Uint8Array([1, ...seed]), 256);
  let priv;
  while (!priv || priv[31] & 32) {
    priv = hmacShaAsU8a(ED25519_CRYPTO, priv || seed, 512);
  }
  priv[0] &= 248;
  priv[31] &= 127;
  priv[31] |= 64;
  return u8aConcat(priv, chainCode);
}

// node_modules/@polkadot/util-crypto/hd/ledger/index.js
function hdLedger(_mnemonic, path) {
  const words = _mnemonic.split(" ").map((s) => s.trim()).filter((s) => s);
  if (![12, 24, 25].includes(words.length)) {
    throw new Error("Expected a mnemonic with 24 words (or 25 including a password)");
  }
  const [mnemonic, password] = words.length === 25 ? [words.slice(0, 24).join(" "), words[24]] : [words.join(" "), ""];
  if (!mnemonicValidate(mnemonic)) {
    throw new Error("Invalid mnemonic passed to ledger derivation");
  } else if (!hdValidatePath(path)) {
    throw new Error("Invalid derivation path");
  }
  const parts = path.split("/").slice(1);
  let seed = ledgerMaster(mnemonic, password);
  for (const p of parts) {
    const n = parseInt(p.replace(/'$/, ""), 10);
    seed = ledgerDerivePrivate(seed, n < HARDENED ? n + HARDENED : n);
  }
  return ed25519PairFromSeed(seed.slice(0, 32));
}

// node_modules/@polkadot/util-crypto/nacl/tweetnacl.js
function L32(x, c) {
  return x << c | x >>> 32 - c;
}
function ld32(x, i) {
  let u = x[i + 3] & 255;
  u = u << 8 | x[i + 2] & 255;
  u = u << 8 | x[i + 1] & 255;
  return u << 8 | x[i + 0] & 255;
}
function st32(x, j, u) {
  for (let i = 0; i < 4; i++) {
    x[j + i] = u & 255;
    u >>>= 8;
  }
}
function vn(x, xi, y, yi, n) {
  let d = 0;
  for (let i = 0; i < n; i++)
    d |= x[xi + i] ^ y[yi + i];
  return (1 & d - 1 >>> 8) - 1;
}
function core(out, inp, k, c, h) {
  const w = new Uint32Array(16), x = new Uint32Array(16), y = new Uint32Array(16), t = new Uint32Array(4);
  let i, j, m;
  for (i = 0; i < 4; i++) {
    x[5 * i] = ld32(c, 4 * i);
    x[1 + i] = ld32(k, 4 * i);
    x[6 + i] = ld32(inp, 4 * i);
    x[11 + i] = ld32(k, 16 + 4 * i);
  }
  for (i = 0; i < 16; i++)
    y[i] = x[i];
  for (i = 0; i < 20; i++) {
    for (j = 0; j < 4; j++) {
      for (m = 0; m < 4; m++)
        t[m] = x[(5 * j + 4 * m) % 16];
      t[1] ^= L32(t[0] + t[3] | 0, 7);
      t[2] ^= L32(t[1] + t[0] | 0, 9);
      t[3] ^= L32(t[2] + t[1] | 0, 13);
      t[0] ^= L32(t[3] + t[2] | 0, 18);
      for (m = 0; m < 4; m++)
        w[4 * j + (j + m) % 4] = t[m];
    }
    for (m = 0; m < 16; m++)
      x[m] = w[m];
  }
  if (h) {
    for (i = 0; i < 16; i++)
      x[i] = x[i] + y[i] | 0;
    for (i = 0; i < 4; i++) {
      x[5 * i] = x[5 * i] - ld32(c, 4 * i) | 0;
      x[6 + i] = x[6 + i] - ld32(inp, 4 * i) | 0;
    }
    for (i = 0; i < 4; i++) {
      st32(out, 4 * i, x[5 * i]);
      st32(out, 16 + 4 * i, x[6 + i]);
    }
  } else {
    for (i = 0; i < 16; i++)
      st32(out, 4 * i, x[i] + y[i] | 0);
  }
}
var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
  const z = new Uint8Array(16), x = new Uint8Array(64);
  let u, i;
  if (!b)
    return 0;
  for (i = 0; i < 16; i++)
    z[i] = 0;
  for (i = 0; i < 8; i++)
    z[i] = n[i];
  while (b >= 64) {
    core(x, z, k, sigma, false);
    for (i = 0; i < 64; i++)
      c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 255) | 0;
      z[i] = u & 255;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    if (m)
      mpos += 64;
  }
  if (b > 0) {
    core(x, z, k, sigma, false);
    for (i = 0; i < b; i++)
      c[cpos + i] = (m ? m[mpos + i] : 0) ^ x[i];
  }
  return 0;
}
function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
  const s = new Uint8Array(32);
  core(s, n, k, sigma, true);
  return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, n.subarray(16), s);
}
function add1305(h, c) {
  let u = 0;
  for (let j = 0; j < 17; j++) {
    u = u + (h[j] + c[j] | 0) | 0;
    h[j] = u & 255;
    u >>>= 8;
  }
}
var minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);
function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  let i, j, u;
  const x = new Uint32Array(17), r = new Uint32Array(17), h = new Uint32Array(17), c = new Uint32Array(17), g = new Uint32Array(17);
  for (j = 0; j < 17; j++)
    r[j] = h[j] = 0;
  for (j = 0; j < 16; j++)
    r[j] = k[j];
  r[3] &= 15;
  r[4] &= 252;
  r[7] &= 15;
  r[8] &= 252;
  r[11] &= 15;
  r[12] &= 252;
  r[15] &= 15;
  while (n > 0) {
    for (j = 0; j < 17; j++)
      c[j] = 0;
    for (j = 0; j < 16 && j < n; ++j)
      c[j] = m[mpos + j];
    c[j] = 1;
    mpos += j;
    n -= j;
    add1305(h, c);
    for (i = 0; i < 17; i++) {
      x[i] = 0;
      for (j = 0; j < 17; j++)
        x[i] = x[i] + h[j] * (j <= i ? r[i - j] : 320 * r[i + 17 - j] | 0) | 0 | 0;
    }
    for (i = 0; i < 17; i++)
      h[i] = x[i];
    u = 0;
    for (j = 0; j < 16; j++) {
      u = u + h[j] | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = u + h[16] | 0;
    h[16] = u & 3;
    u = 5 * (u >>> 2) | 0;
    for (j = 0; j < 16; j++) {
      u = u + h[j] | 0;
      h[j] = u & 255;
      u >>>= 8;
    }
    u = u + h[16] | 0;
    h[16] = u;
  }
  for (j = 0; j < 17; j++)
    g[j] = h[j];
  add1305(h, minusp);
  const s = -(h[16] >>> 7) | 0;
  for (j = 0; j < 17; j++)
    h[j] ^= s & (g[j] ^ h[j]);
  for (j = 0; j < 16; j++)
    c[j] = k[j + 16];
  c[16] = 0;
  add1305(h, c);
  for (j = 0; j < 16; j++)
    out[outpos + j] = h[j];
  return 0;
}
function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  const x = new Uint8Array(16);
  crypto_onetimeauth(x, 0, m, mpos, n, k);
  return vn(h, hpos, x, 0, 16);
}
function crypto_secretbox(c, m, d, n, k) {
  if (d < 32)
    return -1;
  crypto_stream_xor(c, 0, m, 0, d, n, k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (let i = 0; i < 16; i++)
    c[i] = 0;
  return 0;
}
function crypto_secretbox_open(m, c, d, n, k) {
  const x = new Uint8Array(32);
  if (d < 32)
    return -1;
  crypto_stream_xor(x, 0, null, 0, 32, n, k);
  if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0)
    return -1;
  crypto_stream_xor(m, 0, c, 0, d, n, k);
  for (let i = 0; i < 32; i++)
    m[i] = 0;
  return 0;
}
var crypto_secretbox_KEYBYTES = 32;
var crypto_secretbox_NONCEBYTES = 24;
var crypto_secretbox_ZEROBYTES = 32;
var crypto_secretbox_BOXZEROBYTES = 16;
function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES)
    throw new Error("bad key size");
  if (n.length !== crypto_secretbox_NONCEBYTES)
    throw new Error("bad nonce size");
}
function checkArrayTypes(...args) {
  for (let i = 0, count = args.length; i < count; i++) {
    if (!(args[i] instanceof Uint8Array))
      throw new TypeError("unexpected type, use Uint8Array");
  }
}
function naclSecretbox(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  const m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  const c = new Uint8Array(m.length);
  for (let i = 0; i < msg.length; i++)
    m[i + crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
}
function naclSecretboxOpen(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  const c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  const m = new Uint8Array(c.length);
  for (let i = 0; i < box.length; i++)
    c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32)
    return null;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0)
    return null;
  return m.subarray(crypto_secretbox_ZEROBYTES);
}

// node_modules/@polkadot/util-crypto/nacl/decrypt.js
function naclDecrypt(encrypted, nonce, secret) {
  return naclSecretboxOpen(encrypted, nonce, secret);
}

// node_modules/@polkadot/util-crypto/nacl/encrypt.js
function naclEncrypt(message, secret, nonce = randomAsU8a(24)) {
  return {
    encrypted: naclSecretbox(message, nonce, secret),
    nonce
  };
}

// node_modules/@polkadot/util-crypto/scrypt/defaults.js
var ALLOWED_PARAMS = [
  { N: 1 << 13, p: 10, r: 8 },
  { N: 1 << 14, p: 5, r: 8 },
  { N: 1 << 15, p: 3, r: 8 },
  { N: 1 << 15, p: 1, r: 8 },
  { N: 1 << 16, p: 2, r: 8 },
  { N: 1 << 17, p: 1, r: 8 }
];
var DEFAULT_PARAMS = {
  N: 1 << 17,
  p: 1,
  r: 8
};

// node_modules/@polkadot/util-crypto/scrypt/encode.js
function scryptEncode(passphrase, salt = randomAsU8a(), params = DEFAULT_PARAMS, onlyJs) {
  const u8a = u8aToU8a(passphrase);
  return {
    params,
    password: !hasBigInt || !onlyJs && isReady() ? scrypt(u8a, salt, Math.log2(params.N), params.r, params.p) : scrypt2(u8a, salt, objectSpread({ dkLen: 64 }, params)),
    salt
  };
}

// node_modules/@polkadot/util-crypto/scrypt/fromU8a.js
function scryptFromU8a(data) {
  if (!(data instanceof Uint8Array)) {
    throw new Error("Expected input to be a Uint8Array");
  }
  if (data.length < 32 + 12) {
    throw new Error(`Invalid input length: expected 44 bytes, found ${data.length}`);
  }
  const salt = data.subarray(0, 32);
  const N2 = u8aToBn(data.subarray(32, 36), BN_LE_OPTS).toNumber();
  const p = u8aToBn(data.subarray(36, 40), BN_LE_OPTS).toNumber();
  const r = u8aToBn(data.subarray(40, 44), BN_LE_OPTS).toNumber();
  if (N2 > 1 << 20 || p > 4 || r > 16) {
    throw new Error("Scrypt parameters exceed safe limits");
  }
  const isAllowed = ALLOWED_PARAMS.some((preset) => preset.N === N2 && preset.p === p && preset.r === r);
  if (!isAllowed) {
    throw new Error("Invalid injected scrypt params found");
  }
  return { params: { N: N2, p, r }, salt };
}

// node_modules/@polkadot/util-crypto/scrypt/toU8a.js
function scryptToU8a(salt, { N: N2, p, r }) {
  return u8aConcat(salt, bnToU8a(N2, BN_LE_32_OPTS), bnToU8a(p, BN_LE_32_OPTS), bnToU8a(r, BN_LE_32_OPTS));
}

// node_modules/@polkadot/util-crypto/json/constants.js
var ENCODING = ["scrypt", "xsalsa20-poly1305"];
var ENCODING_NONE = ["none"];
var ENCODING_VERSION = "3";
var NONCE_LENGTH = 24;
var SCRYPT_LENGTH = 32 + 3 * 4;

// node_modules/@polkadot/util-crypto/json/decryptData.js
function jsonDecryptData(encrypted, passphrase, encType = ENCODING) {
  if (!encrypted) {
    throw new Error("No encrypted data available to decode");
  } else if (encType.includes("xsalsa20-poly1305") && !passphrase) {
    throw new Error("Password required to decode encrypted data");
  }
  let encoded = encrypted;
  if (passphrase) {
    let password;
    if (encType.includes("scrypt")) {
      const { params, salt } = scryptFromU8a(encrypted);
      password = scryptEncode(passphrase, salt, params).password;
      encrypted = encrypted.subarray(SCRYPT_LENGTH);
    } else {
      password = stringToU8a(passphrase);
    }
    encoded = naclDecrypt(encrypted.subarray(NONCE_LENGTH), encrypted.subarray(0, NONCE_LENGTH), u8aFixLength(password, 256, true));
  }
  if (!encoded) {
    throw new Error("Unable to decode using the supplied passphrase");
  }
  return encoded;
}

// node_modules/@polkadot/util-crypto/json/decrypt.js
function jsonDecrypt({ encoded, encoding }, passphrase) {
  if (!encoded) {
    throw new Error("No encrypted data available to decode");
  }
  return jsonDecryptData(isHex(encoded) ? hexToU8a(encoded) : base64Decode(encoded), passphrase, Array.isArray(encoding.type) ? encoding.type : [encoding.type]);
}

// node_modules/@polkadot/util-crypto/json/encryptFormat.js
function jsonEncryptFormat(encoded, contentType, isEncrypted) {
  return {
    encoded: base64Encode(encoded),
    encoding: {
      content: contentType,
      type: isEncrypted ? ENCODING : ENCODING_NONE,
      version: ENCODING_VERSION
    }
  };
}

// node_modules/@polkadot/util-crypto/json/encrypt.js
function jsonEncrypt(data, contentType, passphrase) {
  let isEncrypted = false;
  let encoded = data;
  if (passphrase) {
    const { params, password, salt } = scryptEncode(passphrase);
    const { encrypted, nonce } = naclEncrypt(encoded, password.subarray(0, 32));
    isEncrypted = true;
    encoded = u8aConcat(scryptToU8a(salt, params), nonce, encrypted);
  }
  return jsonEncryptFormat(encoded, contentType, isEncrypted);
}

// node_modules/@polkadot/util-crypto/signature/verify.js
var secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType, true);
var VERIFIERS_ECDSA = [
  ["ecdsa", secp256k1VerifyHasher("blake2")],
  ["ethereum", secp256k1VerifyHasher("keccak")]
];
var VERIFIERS = [
  ["ed25519", ed25519Verify2],
  ["sr25519", sr25519Verify]
];
function verifyDetect(result, { message, publicKey, signature }, verifiers = [...VERIFIERS, ...VERIFIERS_ECDSA]) {
  result.isValid = verifiers.some(([crypto, verify2]) => {
    try {
      if (verify2(message, signature, publicKey)) {
        result.crypto = crypto;
        return true;
      }
    } catch {
    }
    return false;
  });
  return result;
}
function verifyMultisig(result, { message, publicKey, signature }) {
  if (![0, 1, 2].includes(signature[0]) || ![65, 66].includes(signature.length)) {
    throw new Error(`Unknown crypto type, expected signature prefix [0..2], found ${signature[0]}`);
  }
  if (signature.length === 66) {
    result = verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS_ECDSA);
  } else {
    result = verifyDetect(result, { message, publicKey, signature: signature.subarray(1) }, VERIFIERS);
    if (!result.isValid) {
      result = verifyDetect(result, { message, publicKey, signature }, VERIFIERS_ECDSA);
    }
    if (!result.isValid) {
      result.crypto = "none";
    }
  }
  return result;
}
function getVerifyFn(signature) {
  return [0, 1, 2].includes(signature[0]) && [65, 66].includes(signature.length) ? verifyMultisig : verifyDetect;
}
function signatureVerify(message, signature, addressOrPublicKey) {
  const signatureU8a = u8aToU8a(signature);
  if (![64, 65, 66].includes(signatureU8a.length)) {
    throw new Error(`Invalid signature length, expected [64..66] bytes, found ${signatureU8a.length}`);
  }
  const publicKey = decodeAddress(addressOrPublicKey);
  const input = { message: u8aToU8a(message), publicKey, signature: signatureU8a };
  const result = { crypto: "none", isValid: false, isWrapped: u8aIsWrapped(input.message, true), publicKey };
  const isWrappedBytes = u8aIsWrapped(input.message, false);
  const verifyFn = getVerifyFn(signatureU8a);
  verifyFn(result, input);
  if (result.crypto !== "none" || result.isWrapped && !isWrappedBytes) {
    return result;
  }
  input.message = isWrappedBytes ? u8aUnwrapBytes(input.message) : u8aWrapBytes(input.message);
  return verifyFn(result, input);
}

// node_modules/@polkadot/util-crypto/xxhash/xxhash64.js
var P64_1 = BigInt2("11400714785074694791");
var P64_2 = BigInt2("14029467366897019727");
var P64_3 = BigInt2("1609587929392839161");
var P64_4 = BigInt2("9650029242287828579");
var P64_5 = BigInt2("2870177450012600261");
var U64 = BigInt2("0xffffffffffffffff");
var _7n = BigInt2(7);
var _11n = BigInt2(11);
var _12n = BigInt2(12);
var _16n = BigInt2(16);
var _18n = BigInt2(18);
var _23n = BigInt2(23);
var _27n = BigInt2(27);
var _29n = BigInt2(29);
var _31n = BigInt2(31);
var _32n = BigInt2(32);
var _33n = BigInt2(33);
var _64n = BigInt2(64);
var _256n = BigInt2(256);
function rotl(a, b) {
  const c = a & U64;
  return (c << b | c >> _64n - b) & U64;
}
function fromU8a(u8a, p, count) {
  const bigints = new Array(count);
  let offset = 0;
  for (let i = 0; i < count; i++, offset += 2) {
    bigints[i] = BigInt2(u8a[p + offset] | u8a[p + 1 + offset] << 8);
  }
  let result = _0n;
  for (let i = count - 1; i >= 0; i--) {
    result = (result << _16n) + bigints[i];
  }
  return result;
}
function init(seed, input) {
  const state = {
    seed,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: seed + P64_1 + P64_2,
    v2: seed + P64_2,
    v3: seed,
    v4: seed - P64_1
  };
  if (input.length < 32) {
    state.u8a.set(input);
    state.u8asize = input.length;
    return state;
  }
  const limit = input.length - 32;
  let p = 0;
  if (limit >= 0) {
    const adjustV = (v) => P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);
    do {
      state.v1 = adjustV(state.v1);
      p += 8;
      state.v2 = adjustV(state.v2);
      p += 8;
      state.v3 = adjustV(state.v3);
      p += 8;
      state.v4 = adjustV(state.v4);
      p += 8;
    } while (p <= limit);
  }
  if (p < input.length) {
    state.u8a.set(input.subarray(p, input.length));
    state.u8asize = input.length - p;
  }
  return state;
}
function xxhash64(input, initSeed) {
  const { seed, u8a, u8asize, v1, v2, v3, v4 } = init(BigInt2(initSeed), input);
  let p = 0;
  let h64 = U64 & BigInt2(input.length) + (input.length >= 32 ? ((((rotl(v1, _1n) + rotl(v2, _7n) + rotl(v3, _12n) + rotl(v4, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v2 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v4 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
  while (p <= u8asize - 8) {
    h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
    p += 8;
  }
  if (p + 4 <= u8asize) {
    h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
    p += 4;
  }
  while (p < u8asize) {
    h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * BigInt2(u8a[p++]), _11n);
  }
  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
  h64 = U64 & (h64 ^ h64 >> _32n);
  const result = new Uint8Array(8);
  for (let i = 7; i >= 0; i--) {
    result[i] = Number(h64 % _256n);
    h64 = h64 / _256n;
  }
  return result;
}

// node_modules/@polkadot/util-crypto/xxhash/asU8a.js
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
  const rounds = Math.ceil(bitLength / 64);
  const u8a = u8aToU8a(data);
  if (!hasBigInt || !onlyJs && isReady()) {
    return twox(u8a, rounds);
  }
  const result = new Uint8Array(rounds * 8);
  for (let seed = 0; seed < rounds; seed++) {
    result.set(xxhash64(u8a, seed).reverse(), seed * 8);
  }
  return result;
}
var xxhashAsHex = createAsHex(xxhashAsU8a);

export {
  packageInfo4 as packageInfo,
  cryptoIsReady,
  cryptoWaitReady,
  base58Validate,
  base58Decode,
  base58Encode,
  isBase58,
  blake2AsU8a,
  blake2AsHex,
  checkAddressChecksum,
  allNetworks,
  availableNetworks,
  selectableNetworks,
  decodeAddress,
  addressToEvm,
  checkAddress,
  keyExtractPath,
  keyExtractSuri,
  secp256k1PairFromSeed,
  keyHdkdEcdsa,
  ed25519DeriveHard,
  randomAsU8a,
  randomAsHex,
  randomAsNumber,
  ed25519PairFromSeed,
  ed25519PairFromRandom,
  ed25519PairFromSecret,
  ed25519PairFromString,
  ed25519Sign2 as ed25519Sign,
  ed25519Verify2 as ed25519Verify,
  keyHdkdEd25519,
  sr25519DeriveHard,
  sr25519DeriveSoft,
  keyHdkdSr25519,
  keyFromPath,
  sr25519Agreement,
  sr25519DerivePublic,
  sr25519PairFromSeed,
  sr25519Sign,
  sr25519Verify,
  sr25519VrfSign,
  sr25519VrfVerify,
  encodeAddress,
  deriveAddress,
  createKeyDerived,
  encodeDerivedAddress,
  createKeyMulti,
  encodeMultiAddress,
  addressEq,
  keccakAsU8a,
  keccak256AsU8a,
  keccak512AsU8a,
  keccakAsHex,
  evmToAddress,
  validateAddress,
  isAddress,
  sortAddresses,
  setSS58Format,
  base32Validate,
  isBase32,
  base32Decode,
  base32Encode,
  base64Validate,
  isBase64,
  base64Decode,
  base64Encode,
  base64Pad,
  base64Trim,
  secp256k1Compress2 as secp256k1Compress,
  secp256k1Expand2 as secp256k1Expand,
  secp256k1Recover2 as secp256k1Recover,
  secp256k1Sign2 as secp256k1Sign,
  secp256k1PrivateKeyTweakAdd,
  secp256k1Verify,
  ethereumEncode,
  isEthereumChecksum,
  isEthereumAddress,
  hmacShaAsU8a,
  hmacSha256AsU8a,
  hmacSha512AsU8a,
  hdValidatePath,
  hdEthereum,
  pbkdf2Encode,
  shaAsU8a,
  sha256AsU8a,
  sha512AsU8a,
  mnemonicGenerate,
  mnemonicToEntropy2 as mnemonicToEntropy,
  mnemonicValidate,
  mnemonicToLegacySeed,
  mnemonicToMiniSecret,
  hdLedger,
  naclDecrypt,
  naclEncrypt,
  scryptEncode,
  scryptFromU8a,
  scryptToU8a,
  jsonDecryptData,
  jsonDecrypt,
  jsonEncryptFormat,
  jsonEncrypt,
  signatureVerify,
  xxhashAsU8a,
  xxhashAsHex
};
//# sourceMappingURL=chunk-WDJM77FW.js.map
