import {
  base58,
  base64,
  blake2b,
  blake2b2,
  ed25519,
  ed25519KeypairFromSeed,
  esm_default,
  hmac,
  hmacSha256,
  hmacSha512,
  isReady,
  keccak256,
  keccak512,
  keccak_256,
  keccak_512,
  require_bn,
  secp256k1,
  secp256k1Compress,
  secp256k1Expand,
  secp256k1FromSeed,
  secp256k1Recover,
  sha256,
  sha2562,
  sha512,
  sha5122,
  sr25519DeriveKeypairHard,
  sr25519DeriveKeypairSoft,
  twox,
  utils,
  waitReady
} from "./chunk-FZBI2DIJ.js";
import {
  __publicField,
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/@polkadot/x-global/packageInfo.js
var packageInfo = { name: "@polkadot/x-global", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/x-global/index.js
function evaluateThis(fn) {
  return fn("return this");
}
var xglobal = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : evaluateThis(Function);
function extractGlobal(name, fallback) {
  return typeof xglobal[name] === "undefined" ? fallback : xglobal[name];
}
function exposeGlobal(name, fallback) {
  if (typeof xglobal[name] === "undefined") {
    xglobal[name] = fallback;
  }
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textdecoder/fallback.js
var TextDecoder = class {
  constructor(encoding) {
    __publicField(this, "__encoding");
    this.__encoding = encoding;
  }
  decode(value) {
    let result = "";
    for (let i = 0, count = value.length; i < count; i++) {
      result += String.fromCharCode(value[i]);
    }
    return result;
  }
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textdecoder/packageInfo.js
var packageInfo2 = { name: "@polkadot/x-textdecoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textdecoder/browser.js
var TextDecoder2 = extractGlobal("TextDecoder", TextDecoder);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textencoder/fallback.js
var TextEncoder = class {
  encode(value) {
    const count = value.length;
    const u8a = new Uint8Array(count);
    for (let i = 0; i < count; i++) {
      u8a[i] = value.charCodeAt(i);
    }
    return u8a;
  }
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textencoder/packageInfo.js
var packageInfo3 = { name: "@polkadot/x-textencoder", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-textencoder/browser.js
var TextEncoder2 = extractGlobal("TextEncoder", TextEncoder);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/function.js
function isFunction(value) {
  return typeof value === "function";
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/detectPackage.js
var DEDUPE = "Either remove and explicitly install matching versions or dedupe using your package manager.\nThe following conflicting packages were found:";
var POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG = "POLKADOTJS_DISABLE_ESM_CJS_WARNING";
function getEntry(name) {
  const _global = xglobal;
  if (!_global.__polkadotjs) {
    _global.__polkadotjs = {};
  }
  if (!_global.__polkadotjs[name]) {
    _global.__polkadotjs[name] = [];
  }
  return _global.__polkadotjs[name];
}
function formatDisplay(all, fmt) {
  let max = 0;
  for (let i = 0, count = all.length; i < count; i++) {
    max = Math.max(max, all[i].version.length);
  }
  return all.map((d) => `	${fmt(d.version.padEnd(max), d).join("	")}`).join("\n");
}
function formatInfo(version, { name }) {
  return [
    version,
    name
  ];
}
function formatVersion(version, { path, type }) {
  let extracted;
  if (path && path.length >= 5) {
    const nmIndex = path.indexOf("node_modules");
    extracted = nmIndex === -1 ? path : path.substring(nmIndex);
  } else {
    extracted = "<unknown>";
  }
  return [
    `${`${type || ""}`.padStart(3)} ${version}`,
    extracted
  ];
}
function getPath(infoPath, pathOrFn) {
  if (infoPath) {
    return infoPath;
  } else if (isFunction(pathOrFn)) {
    try {
      return pathOrFn() || "";
    } catch {
      return "";
    }
  }
  return pathOrFn || "";
}
function warn(pre, all, fmt) {
  console.warn(`${pre}
${DEDUPE}
${formatDisplay(all, fmt)}`);
}
function detectPackage({ name, path, type, version }, pathOrFn, deps = []) {
  var _a, _b;
  if (!name.startsWith("@polkadot")) {
    throw new Error(`Invalid package descriptor ${name}`);
  }
  const entry = getEntry(name);
  entry.push({ path: getPath(path, pathOrFn), type, version });
  const entriesSameVersion = entry.every((e) => e.version === version);
  const esmCjsWarningDisabled = ((_b = (_a = xglobal.process) == null ? void 0 : _a.env) == null ? void 0 : _b[POLKADOTJS_DISABLE_ESM_CJS_WARNING_FLAG]) === "1";
  const multipleEntries = entry.length !== 1;
  const disableWarnings = esmCjsWarningDisabled && entriesSameVersion;
  if (multipleEntries && !disableWarnings) {
    warn(`${name} has multiple versions, ensure that there is only one installed.`, entry, formatVersion);
  } else {
    const mismatches = deps.filter((d) => d && d.version !== version);
    if (mismatches.length) {
      warn(`${name} requires direct dependencies exactly matching version ${version}.`, mismatches, formatInfo);
    }
  }
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/packageInfo.js
var packageInfo4 = { name: "@polkadot/util", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/packageDetect.js
detectPackage(packageInfo4, null, [packageInfo2, packageInfo3]);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bi/helpers.js
function createCmp(cmp) {
  return (...items) => {
    const count = items.length;
    if (count === 0) {
      throw new Error("Must provide one or more arguments");
    }
    let result = items[0];
    for (let i = 1; i < count; i++) {
      if (cmp(items[i], result)) {
        result = items[i];
      }
    }
    return result;
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bi/min.js
var nMax = createCmp((a, b) => a > b);
var nMin = createCmp((a, b) => a < b);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-bigint/packageInfo.js
var packageInfo5 = { name: "@polkadot/x-bigint", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-bigint/index.js
function invalidFallback() {
  return Number.NaN;
}
var BigInt = extractGlobal("BigInt", invalidFallback);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bi/consts.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _6n = BigInt(6);
var _7n = BigInt(7);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _10n = BigInt(10);
var _100n = BigInt(100);
var _1000n = BigInt(1e3);
var _1Mn = BigInt(1e6);
var _1Bn = BigInt(1e9);
var _1Qn = _1Bn * _1Bn;
var _2pow53n = BigInt(Number.MAX_SAFE_INTEGER);
var _sqrt2pow53n = BigInt(94906265);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/toBigInt.js
var U8_MAX = BigInt(256);
var U16_MAX = BigInt(256 * 256);
var U64_MAX = BigInt("0x10000000000000000");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/hex/toU8a.js
var CHR = "0123456789abcdef";
var U8 = new Uint8Array(256);
var U16 = new Uint8Array(256 * 256);
for (let i = 0, count = CHR.length; i < count; i++) {
  U8[CHR[i].charCodeAt(0) | 0] = i | 0;
  if (i > 9) {
    U8[CHR[i].toUpperCase().charCodeAt(0) | 0] = i | 0;
  }
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U16[s | j] = U8[i] << 4 | U8[j];
  }
}
function hexToU8a(value, bitLength = -1) {
  if (!value) {
    return new Uint8Array();
  }
  let s = value.startsWith("0x") ? 2 : 0;
  const decLength = Math.ceil((value.length - s) / 2);
  const endLength = Math.ceil(bitLength === -1 ? decLength : bitLength / 8);
  const result = new Uint8Array(endLength);
  const offset = endLength > decLength ? endLength - decLength : 0;
  for (let i = offset; i < endLength; i++, s += 2) {
    result[i] = U16[value.charCodeAt(s) << 8 | value.charCodeAt(s + 1)];
  }
  return result;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bn/bn.js
var import_bn = __toESM(require_bn(), 1);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/bn.js
function isBn(value) {
  return import_bn.default.isBN(value);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/hex.js
var REGEX_HEX_PREFIXED = /^0x[\da-fA-F]+$/;
var REGEX_HEX_NOPREFIX = /^[\da-fA-F]+$/;
function isHex(value, bitLength = -1, ignoreLength) {
  return typeof value === "string" && (value === "0x" || REGEX_HEX_PREFIXED.test(value)) && (bitLength === -1 ? ignoreLength || value.length % 2 === 0 : value.length === 2 + Math.ceil(bitLength / 4));
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/object.js
function isObject(value) {
  return !!value && typeof value === "object";
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/helpers.js
function isOn(...fns) {
  return (value) => (isObject(value) || isFunction(value)) && fns.every((f) => isFunction(value[f]));
}
function isOnFunction(...fns) {
  return (value) => isFunction(value) && fns.every((f) => isFunction(value[f]));
}
function isOnObject(...fns) {
  return (value) => isObject(value) && fns.every((f) => isFunction(value[f]));
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/toBigInt.js
var isToBigInt = isOn("toBigInt");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/toBn.js
var isToBn = isOn("toBn");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/has.js
var hasBigInt = typeof BigInt === "function" && typeof BigInt.asIntN === "function";
var hasBuffer = typeof xglobal.Buffer === "function" && typeof xglobal.Buffer.isBuffer === "function";
var hasProcess = typeof xglobal.process === "object";

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/buffer.js
function isBuffer(value) {
  return hasBuffer && !!value && isFunction(value.readDoubleLE) && xglobal.Buffer.isBuffer(value);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/u8a.js
function isU8a(value) {
  return (value && value.constructor) === Uint8Array || value instanceof Uint8Array;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/string/toU8a.js
var encoder = new TextEncoder2();
function stringToU8a(value) {
  return value ? encoder.encode(value.toString()) : new Uint8Array();
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/toU8a.js
function u8aToU8a(value, strict = false) {
  if (strict && (value === null || value === void 0)) {
    throw new Error("u8aToU8a: Expected non-null, non-undefined value");
  }
  return isU8a(value) ? isBuffer(value) ? new Uint8Array(value) : value : isHex(value) ? hexToU8a(value) : Array.isArray(value) ? new Uint8Array(value) : stringToU8a(value);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/concat.js
function u8aConcat(...list) {
  const count = list.length;
  const u8as = new Array(count);
  let length = 0;
  for (let i = 0; i < count; i++) {
    u8as[i] = u8aToU8a(list[i]);
    length += u8as[i].length;
  }
  return u8aConcatStrict(u8as, length);
}
function u8aConcatStrict(u8as, length = 0) {
  const count = u8as.length;
  let offset = 0;
  if (!length) {
    for (let i = 0; i < count; i++) {
      length += u8as[i].length;
    }
  }
  const result = new Uint8Array(length);
  for (let i = 0; i < count; i++) {
    result.set(u8as[i], offset);
    offset += u8as[i].length;
  }
  return result;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/empty.js
function u8aEmpty(value) {
  const len = value.length | 0;
  for (let i = 0; i < len; i++) {
    if (value[i] | 0) {
      return false;
    }
  }
  return true;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/eq.js
function u8aEq(a, b) {
  const u8aa = u8aToU8a(a);
  const u8ab = u8aToU8a(b);
  if (u8aa.length === u8ab.length) {
    const dvA = new DataView(u8aa.buffer, u8aa.byteOffset);
    const dvB = new DataView(u8ab.buffer, u8ab.byteOffset);
    const mod = u8aa.length % 4 | 0;
    const length = u8aa.length - mod | 0;
    for (let i = 0; i < length; i += 4) {
      if (dvA.getUint32(i) !== dvB.getUint32(i)) {
        return false;
      }
    }
    for (let i = length, count = u8aa.length; i < count; i++) {
      if (u8aa[i] !== u8ab[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/toHex.js
var U82 = new Array(256);
var U162 = new Array(256 * 256);
for (let n = 0; n < 256; n++) {
  U82[n] = n.toString(16).padStart(2, "0");
}
for (let i = 0; i < 256; i++) {
  const s = i << 8;
  for (let j = 0; j < 256; j++) {
    U162[s | j] = U82[i] + U82[j];
  }
}
function hex(value, result) {
  const mod = value.length % 2 | 0;
  const length = value.length - mod | 0;
  for (let i = 0; i < length; i += 2) {
    result += U162[value[i] << 8 | value[i + 1]];
  }
  if (mod) {
    result += U82[value[length] | 0];
  }
  return result;
}
function u8aToHex(value, bitLength = -1, isPrefixed = true) {
  const empty = isPrefixed ? "0x" : "";
  if (!(value == null ? void 0 : value.length)) {
    return empty;
  } else if (bitLength > 0) {
    const length = Math.ceil(bitLength / 8);
    if (value.length > length) {
      return `${hex(value.subarray(0, length / 2), empty)}…${hex(value.subarray(value.length - length / 2), "")}`;
    }
  }
  return hex(value, empty);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/toString.js
var decoder = new TextDecoder2("utf-8");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/u8a/wrap.js
var U8A_WRAP_ETHEREUM = u8aToU8a("Ethereum Signed Message:\n");
var U8A_WRAP_PREFIX = u8aToU8a("<Bytes>");
var U8A_WRAP_POSTFIX = u8aToU8a("</Bytes>");
var WRAP_LEN = U8A_WRAP_PREFIX.length + U8A_WRAP_POSTFIX.length;
function u8aIsWrapped(u8a, withEthereum) {
  return u8a.length >= WRAP_LEN && u8aEq(u8a.subarray(0, U8A_WRAP_PREFIX.length), U8A_WRAP_PREFIX) && u8aEq(u8a.slice(-U8A_WRAP_POSTFIX.length), U8A_WRAP_POSTFIX) || withEthereum && u8a.length >= U8A_WRAP_ETHEREUM.length && u8aEq(u8a.subarray(0, U8A_WRAP_ETHEREUM.length), U8A_WRAP_ETHEREUM);
}
function u8aUnwrapBytes(bytes) {
  const u8a = u8aToU8a(bytes);
  return u8aIsWrapped(u8a, false) ? u8a.subarray(U8A_WRAP_PREFIX.length, u8a.length - U8A_WRAP_POSTFIX.length) : u8a;
}
function u8aWrapBytes(bytes) {
  const u8a = u8aToU8a(bytes);
  return u8aIsWrapped(u8a, true) ? u8a : u8aConcatStrict([U8A_WRAP_PREFIX, u8a, U8A_WRAP_POSTFIX]);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bi/toU8a.js
var DIV = BigInt(256);
var NEG_MASK = BigInt(255);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/hex/stripPrefix.js
function hexStripPrefix(value) {
  if (!value || value === "0x") {
    return "";
  } else if (REGEX_HEX_PREFIXED.test(value)) {
    return value.substring(2);
  } else if (REGEX_HEX_NOPREFIX.test(value)) {
    return value;
  }
  throw new Error(`Expected hex value to convert, found '${value}'`);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/hex/toBn.js
function hexToBn(value, { isLe = false, isNegative = false } = {}) {
  if (!value || value === "0x") {
    return new import_bn.default(0);
  }
  const stripped = hexStripPrefix(value);
  const bn = new import_bn.default(stripped, 16, isLe ? "le" : "be");
  return isNegative ? bn.fromTwos(stripped.length * 4) : bn;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bn/min.js
var bnMax = createCmp((a, b) => a.gt(b));
var bnMin = createCmp((a, b) => a.lt(b));

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bn/consts.js
var BN_ZERO = new import_bn.default(0);
var BN_ONE = new import_bn.default(1);
var BN_TWO = new import_bn.default(2);
var BN_THREE = new import_bn.default(3);
var BN_FOUR = new import_bn.default(4);
var BN_FIVE = new import_bn.default(5);
var BN_SIX = new import_bn.default(6);
var BN_SEVEN = new import_bn.default(7);
var BN_EIGHT = new import_bn.default(8);
var BN_NINE = new import_bn.default(9);
var BN_TEN = new import_bn.default(10);
var BN_HUNDRED = new import_bn.default(100);
var BN_THOUSAND = new import_bn.default(1e3);
var BN_MILLION = new import_bn.default(1e6);
var BN_BILLION = new import_bn.default(1e9);
var BN_QUINTILL = BN_BILLION.mul(BN_BILLION);
var BN_MAX_INTEGER = new import_bn.default(Number.MAX_SAFE_INTEGER);
var BN_SQRT_MAX_INTEGER = new import_bn.default(94906265);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/bigInt.js
function isBigInt(value) {
  return typeof value === "bigint";
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bn/toBn.js
function bnToBn(value) {
  return value ? import_bn.default.isBN(value) ? value : isHex(value) ? hexToBn(value.toString()) : isBigInt(value) ? new import_bn.default(value.toString()) : isToBn(value) ? value.toBn() : isToBigInt(value) ? new import_bn.default(value.toBigInt().toString()) : new import_bn.default(value) : new import_bn.default(0);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/bn/toU8a.js
var DEFAULT_OPTS = { bitLength: -1, isLe: true, isNegative: false };
function bnToU8a(value, { bitLength = -1, isLe = true, isNegative = false } = DEFAULT_OPTS) {
  const valueBn = bnToBn(value);
  const byteLength = bitLength === -1 ? Math.ceil(valueBn.bitLength() / 8) : Math.ceil((bitLength || 0) / 8);
  if (!value) {
    return bitLength === -1 ? new Uint8Array(1) : new Uint8Array(byteLength);
  }
  const output = new Uint8Array(byteLength);
  const bn = isNegative ? valueBn.toTwos(byteLength * 8) : valueBn;
  output.set(bn.toArray(isLe ? "le" : "be", byteLength), 0);
  return output;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/compact/toU8a.js
var MAX_U8 = BN_TWO.pow(new import_bn.default(8 - 2)).isub(BN_ONE);
var MAX_U16 = BN_TWO.pow(new import_bn.default(16 - 2)).isub(BN_ONE);
var MAX_U32 = BN_TWO.pow(new import_bn.default(32 - 2)).isub(BN_ONE);
var BL_16 = { bitLength: 16 };
var BL_32 = { bitLength: 32 };
function compactToU8a(value) {
  const bn = bnToBn(value);
  if (bn.lte(MAX_U8)) {
    return new Uint8Array([bn.toNumber() << 2]);
  } else if (bn.lte(MAX_U16)) {
    return bnToU8a(bn.shln(2).iadd(BN_ONE), BL_16);
  } else if (bn.lte(MAX_U32)) {
    return bnToU8a(bn.shln(2).iadd(BN_TWO), BL_32);
  }
  const u8a = bnToU8a(bn);
  let length = u8a.length;
  while (u8a[length - 1] === 0) {
    length--;
  }
  if (length < 4) {
    throw new Error("Invalid length, previous checks match anything less than 2^30");
  }
  return u8aConcatStrict([
    // subtract 4 as minimum (also catered for in decoding)
    new Uint8Array([(length - 4 << 2) + 3]),
    u8a.subarray(0, length)
  ]);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/compact/addLength.js
function compactAddLength(input) {
  return u8aConcatStrict([
    compactToU8a(input.length),
    input
  ]);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/extractTime.js
var MIN_MS = 60 * 1e3;
var HR_MS = MIN_MS * 60;
var DAY_MS = HR_MS * 24;

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/boolean.js
function isBoolean(value) {
  return typeof value === "boolean";
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/format/formatDecimal.js
var NUMBER_REGEX = new RegExp("(\\d+?)(?=(\\d{3})+(?!\\d)|$)", "g");
function formatDecimal(value, separator = ",") {
  const isNegative = value[0].startsWith("-");
  const matched = isNegative ? value.substring(1).match(NUMBER_REGEX) : value.match(NUMBER_REGEX);
  return matched ? `${isNegative ? "-" : ""}${matched.join(separator)}` : value;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/format/getSeparator.js
function getSeparator(locale) {
  return {
    decimal: 0.1.toLocaleString(locale, { useGrouping: false }).charAt(1),
    thousand: 1e3.toLocaleString(locale, { useGrouping: true }).replace(/\d/g, "").charAt(0)
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/format/si.js
var SI_MID = 8;
var SI = [
  { power: -24, text: "yocto", value: "y" },
  { power: -21, text: "zepto", value: "z" },
  { power: -18, text: "atto", value: "a" },
  { power: -15, text: "femto", value: "f" },
  { power: -12, text: "pico", value: "p" },
  { power: -9, text: "nano", value: "n" },
  { power: -6, text: "micro", value: "µ" },
  { power: -3, text: "milli", value: "m" },
  { power: 0, text: "Unit", value: "-" },
  // position 8
  { power: 3, text: "Kilo", value: "k" },
  { power: 6, text: "Mill", value: "M" },
  // Mega, M
  { power: 9, text: "Bill", value: "B" },
  // Giga, G
  { power: 12, text: "Tril", value: "T" },
  // Tera, T
  { power: 15, text: "Peta", value: "P" },
  { power: 18, text: "Exa", value: "E" },
  { power: 21, text: "Zeta", value: "Z" },
  { power: 24, text: "Yotta", value: "Y" }
];
function findSi(type) {
  for (let i = 0, count = SI.length; i < count; i++) {
    if (SI[i].value === type) {
      return SI[i];
    }
  }
  return SI[SI_MID];
}
function calcSi(text, decimals, forceUnit) {
  if (forceUnit) {
    return findSi(forceUnit);
  }
  const siDefIndex = SI_MID - 1 + Math.ceil((text.length - decimals) / 3);
  return SI[siDefIndex] || SI[siDefIndex < 0 ? 0 : SI.length - 1];
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/format/formatBalance.js
var DEFAULT_DECIMALS = 0;
var DEFAULT_UNIT = SI[SI_MID].text;
var defaultDecimals = DEFAULT_DECIMALS;
var defaultUnit = DEFAULT_UNIT;
function _formatBalance(input, { decimals = defaultDecimals, forceUnit, locale = "en", withAll = false, withSi = true, withSiFull = false, withUnit = true, withZero = true } = {}) {
  let text = bnToBn(input).toString();
  if (text.length === 0 || text === "0") {
    return "0";
  }
  let sign = "";
  if (text[0].startsWith("-")) {
    sign = "-";
    text = text.substring(1);
  }
  const si = calcSi(text, decimals, forceUnit);
  const mid = text.length - (decimals + si.power);
  const pre = mid <= 0 ? "0" : text.substring(0, mid);
  let post = text.padStart(mid < 0 ? decimals : 1, "0").substring(mid < 0 ? 0 : mid).padEnd(withAll ? Math.max(decimals, 4) : 4, "0").substring(0, withAll ? Math.max(4, decimals + si.power) : 4);
  if (!withZero) {
    let end = post.length - 1;
    do {
      if (post[end] === "0") {
        end--;
      }
    } while (post[end] === "0");
    post = post.substring(0, end + 1);
  }
  const unit = isBoolean(withUnit) ? SI[SI_MID].text : withUnit;
  const units = withSi || withSiFull ? si.value === "-" ? withUnit ? ` ${unit}` : "" : ` ${withSiFull ? `${si.text}${withUnit ? " " : ""}` : si.value}${withUnit ? unit : ""}` : "";
  const { decimal, thousand } = getSeparator(locale);
  return `${sign}${formatDecimal(pre, thousand)}${post && `${decimal}${post}`}${units}`;
}
var formatBalance = _formatBalance;
formatBalance.calcSi = (text, decimals = defaultDecimals) => calcSi(text, decimals);
formatBalance.findSi = findSi;
formatBalance.getDefaults = () => {
  return {
    decimals: defaultDecimals,
    unit: defaultUnit
  };
};
formatBalance.getOptions = (decimals = defaultDecimals) => {
  return SI.filter(({ power }) => power < 0 ? decimals + power >= 0 : true);
};
formatBalance.setDefaults = ({ decimals, unit }) => {
  defaultDecimals = (Array.isArray(decimals) ? decimals[0] : decimals) ?? defaultDecimals;
  defaultUnit = (Array.isArray(unit) ? unit[0] : unit) ?? defaultUnit;
  SI[SI_MID].text = defaultUnit;
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/format/formatDate.js
function zeroPad(value) {
  return value.toString().padStart(2, "0");
}
function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/class.js
var isClass = isOnFunction("isPrototypeOf", "hasOwnProperty");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/codec.js
var checkCodec = isOnObject("toHex", "toHuman", "toU8a");
var checkRegistry = isOnObject("get");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/compact.js
var isCompact = isOnObject("toBigInt", "toBn", "toNumber", "unwrap");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/ip.js
var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
var v6s = "[a-fA-F\\d]{1,4}";
var v6 = `
(?:
(?:${v6s}:){7}(?:${v6s}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6s}:){6}(?:${v4}|:${v6s}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6s}:){5}(?::${v4}|(?::${v6s}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6s}:){4}(?:(?::${v6s}){0,1}:${v4}|(?::${v6s}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6s}:){3}(?:(?::${v6s}){0,2}:${v4}|(?::${v6s}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6s}:){2}(?:(?::${v6s}){0,3}:${v4}|(?::${v6s}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6s}:){1}(?:(?::${v6s}){0,4}:${v4}|(?::${v6s}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6s}){0,5}:${v4}|(?::${v6s}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
var v4exact = new RegExp(`^${v4}$`);
var v6exact = new RegExp(`^${v6}$`);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/observable.js
var isObservable = isOn("next");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/promise.js
var isPromise = isOnObject("catch", "then");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/riscv.js
var ELF_MAGIC = new Uint8Array([127, 69, 76, 70]);
var PVM_MAGIC = new Uint8Array([80, 86, 77, 0]);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/is/wasm.js
var WASM_MAGIC = new Uint8Array([0, 97, 115, 109]);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/noop.js
function noop() {
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/logger.js
var logTo = {
  debug: "log",
  error: "error",
  log: "log",
  warn: "warn"
};
function formatOther(value) {
  if (value && isObject(value) && value.constructor === Object) {
    const result = {};
    for (const [k, v] of Object.entries(value)) {
      result[k] = loggerFormat(v);
    }
    return result;
  }
  return value;
}
function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if (isBn(value)) {
    return value.toString();
  } else if (isU8a(value) || isBuffer(value)) {
    return u8aToHex(u8aToU8a(value));
  }
  return formatOther(value);
}
function formatWithLength(maxLength) {
  return (v) => {
    if (maxLength <= 0) {
      return v;
    }
    const r = `${v}`;
    return r.length < maxLength ? v : `${r.substring(0, maxLength)} ...`;
  };
}
function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && isFunction(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }
  console[logTo[log]](formatDate(/* @__PURE__ */ new Date()), type, ...values.map(loggerFormat).map(formatWithLength(maxSize)));
}
function isDebugOn(e, type) {
  return !!e && (e === "*" || type === e || e.endsWith("*") && type.startsWith(e.slice(0, -1)));
}
function isDebugOff(e, type) {
  return !!e && (e.startsWith("-") && (type === e.slice(1) || e.endsWith("*") && type.startsWith(e.slice(1, -1))));
}
function getDebugFlag(env, type) {
  let flag = false;
  for (const e of env) {
    if (isDebugOn(e, type)) {
      flag = true;
    } else if (isDebugOff(e, type)) {
      flag = false;
    }
  }
  return flag;
}
function parseEnv(type) {
  var _a, _b, _c, _d;
  const maxSize = parseInt(((_b = (_a = xglobal.process) == null ? void 0 : _a.env) == null ? void 0 : _b["DEBUG_MAX"]) || "-1", 10);
  return [
    getDebugFlag((((_d = (_c = xglobal.process) == null ? void 0 : _c.env) == null ? void 0 : _d["DEBUG"]) || "").toLowerCase().split(","), type),
    isNaN(maxSize) ? -1 : maxSize
  ];
}
function logger(origin) {
  const type = `${origin.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(origin.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply("debug", type, values, maxSize) : noop,
    error: (...values) => apply("error", type, values),
    log: (...values) => apply("log", type, values),
    noop,
    warn: (...values) => apply("warn", type, values)
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/object/spread.js
function objectSpread(dest, ...sources) {
  const filterProps = /* @__PURE__ */ new Set(["__proto__", "constructor", "prototype"]);
  for (let i = 0, count = sources.length; i < count; i++) {
    const src = sources[i];
    if (src) {
      if (typeof src.entries === "function") {
        for (const [key, value] of src.entries()) {
          if (!filterProps.has(key)) {
            dest[key] = value;
          }
        }
      } else {
        const sanitizedSrc = /* @__PURE__ */ Object.create(null);
        for (const [key, value] of Object.entries(src)) {
          if (!filterProps.has(key)) {
            sanitizedSrc[key] = value;
          }
        }
        Object.assign(dest, sanitizedSrc);
      }
    }
  }
  return dest;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/string/camelCase.js
var CC_TO_UP = new Array(256);
var CC_TO_LO = new Array(256);
for (let i = 0, count = CC_TO_UP.length; i < count; i++) {
  CC_TO_LO[i] = String.fromCharCode(i).toLowerCase();
  CC_TO_UP[i] = String.fromCharCode(i).toUpperCase();
}
function formatAllCaps(w) {
  return w.slice(0, w.length - 1).toLowerCase() + CC_TO_UP[w.charCodeAt(w.length - 1)];
}
function converter(format) {
  return (value) => {
    const parts = value.replace(/[-_., ]+/g, " ").trim().split(" ");
    let result = "";
    for (let i = 0, count = parts.length; i < count; i++) {
      const w = parts[i];
      result += format(/^[\dA-Z]+$/.test(w) ? w.toLowerCase() : w.replace(/^[\dA-Z]{2,}[^a-z]/, formatAllCaps), i);
    }
    return result;
  };
}
var stringCamelCase = converter((w, i) => (i ? CC_TO_UP[w.charCodeAt(0)] : CC_TO_LO[w.charCodeAt(0)]) + w.slice(1));
var stringPascalCase = converter((w) => CC_TO_UP[w.charCodeAt(0)] + w.slice(1));

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util/string/lowerFirst.js
function converter2(map) {
  return (value) => value ? map[value.charCodeAt(0)] + value.slice(1) : "";
}
var stringLowerFirst = converter2(CC_TO_LO);
var stringUpperFirst = converter2(CC_TO_UP);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/packageInfo.js
var packageInfo6 = { name: "@polkadot/networks", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-randomvalues/packageInfo.js
var packageInfo7 = { name: "@polkadot/x-randomvalues", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-randomvalues/browser.js
var crypto = xglobal.crypto;
function getRandomValues(arr) {
  return crypto.getRandomValues(arr);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/packageInfo.js
var packageInfo8 = { name: "@polkadot/util-crypto", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "13.5.9" };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/packageDetect.js
detectPackage(packageInfo8, null, [packageInfo6, packageInfo7, packageInfo4]);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/x-bigint/shim.js
exposeGlobal("BigInt", BigInt);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/crypto.js
function cryptoWaitReady() {
  return waitReady().then(() => {
    if (!isReady()) {
      throw new Error("Unable to initialize @polkadot/util-crypto");
    }
    return true;
  }).catch(() => false);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/bundleInit.js
cryptoWaitReady().catch(() => {
});

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/base32/helpers.js
function createDecode({ coder, ipfs }, validate) {
  return (value, ipfsCompat) => {
    validate(value, ipfsCompat);
    return coder.decode(ipfs && ipfsCompat ? value.substring(1) : value);
  };
}
function createEncode({ coder, ipfs }) {
  return (value, ipfsCompat) => {
    const out = coder.encode(u8aToU8a(value));
    return ipfs && ipfsCompat ? `${ipfs}${out}` : out;
  };
}
function createIs(validate) {
  return (value, ipfsCompat) => {
    try {
      return validate(value, ipfsCompat);
    } catch {
      return false;
    }
  };
}
function createValidate({ chars: chars2, ipfs, type, withPadding }) {
  return (value, ipfsCompat) => {
    if (typeof value !== "string") {
      throw new Error(`Expected ${type} string input`);
    } else if (ipfs && ipfsCompat && !value.startsWith(ipfs)) {
      throw new Error(`Expected ipfs-compatible ${type} to start with '${ipfs}'`);
    }
    for (let i = ipfsCompat ? 1 : 0, count = value.length; i < count; i++) {
      if (chars2.includes(value[i])) {
      } else if (withPadding && value[i] === "=") {
        if (i === count - 1) {
        } else if (value[i + 1] === "=") {
        } else {
          throw new Error(`Invalid ${type} padding sequence "${value[i]}${value[i + 1]}" at index ${i}`);
        }
      } else {
        throw new Error(`Invalid ${type} character "${value[i]}" (0x${value.charCodeAt(i).toString(16)}) at index ${i}`);
      }
    }
    return true;
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/base58/bs58.js
var config = {
  chars: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",
  coder: base58,
  ipfs: "z",
  type: "base58"
};
var base58Validate = createValidate(config);
var base58Decode = createDecode(config, base58Validate);
var base58Encode = createEncode(config);
var isBase58 = createIs(base58Validate);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/helpers.js
function createAsHex(fn) {
  return (...args) => u8aToHex(fn(...args));
}
function createBitHasher(bitLength, fn) {
  return (data, onlyJs) => fn(data, bitLength, onlyJs);
}
function createDualHasher(wa, js) {
  return (value, bitLength = 256, onlyJs) => {
    const u8a = u8aToU8a(value);
    return !hasBigInt || !onlyJs && isReady() ? wa[bitLength](u8a) : js[bitLength](u8a);
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/blake2/asU8a.js
function blake2AsU8a(data, bitLength = 256, key, onlyJs) {
  const byteLength = Math.ceil(bitLength / 8);
  const u8a = u8aToU8a(data);
  return !hasBigInt || !onlyJs && isReady() ? blake2b(u8a, u8aToU8a(key), byteLength) : key ? blake2b2(u8a, { dkLen: byteLength, key }) : blake2b2(u8a, { dkLen: byteLength });
}
var blake2AsHex = createAsHex(blake2AsU8a);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/sshash.js
var SS58_PREFIX = stringToU8a("SS58PRE");
function sshash(key) {
  return blake2AsU8a(u8aConcat(SS58_PREFIX, key), 512);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/checksum.js
function checkAddressChecksum(decoded) {
  const ss58Length = decoded[0] & 64 ? 2 : 1;
  const ss58Decoded = ss58Length === 1 ? decoded[0] : (decoded[0] & 63) << 2 | decoded[1] >> 6 | (decoded[1] & 63) << 8;
  const isPublicKey = [34 + ss58Length, 35 + ss58Length].includes(decoded.length);
  const length = decoded.length - (isPublicKey ? 2 : 1);
  const hash = sshash(decoded.subarray(0, length));
  const isValid = (decoded[0] & 128) === 0 && ![46, 47].includes(decoded[0]) && (isPublicKey ? decoded[decoded.length - 2] === hash[0] && decoded[decoded.length - 1] === hash[1] : decoded[decoded.length - 1] === hash[0]);
  return [isValid, length, ss58Length, ss58Decoded];
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/defaults/genesis.js
var knownGenesis = {
  acala: [
    "0xfc41b9bd8ef8fe53d58c7ea67c794c7ec9a73daf05e6d54b14ff6342c99ba64c"
  ],
  ajuna: [
    "0xe358eb1d11b31255a286c12e44fe6780b7edb171d657905a97e39f71d9c6c3ee"
  ],
  "aleph-node": [
    "0x70255b4d28de0fc4e1a193d7e175ad1ccef431598211c55538f1018651a0344e"
  ],
  astar: [
    "0x9eb76c5184c4ab8679d2d5d819fdf90b9c001403e9e17da2e14b6d8aec4029c6"
  ],
  basilisk: [
    "0xa85cfb9b9fd4d622a5b28289a02347af987d8f73fa3108450e2b4a11c1ce5755"
  ],
  bifrost: [
    "0x262e1b2ad728475fd6fe88e62d34c200abe6fd693931ddad144059b1eb884e5b"
  ],
  "bifrost-kusama": [
    "0x9f28c6a68e0fc9646eff64935684f6eeeece527e37bbe1f213d22caa1d9d6bed"
  ],
  bittensor: [
    "0x2f0555cc76fc2840a25a6ea3b9637146806f1f44b090c175ffde2a7e5ab36c03"
  ],
  centrifuge: [
    "0xb3db41421702df9a7fcac62b53ffeac85f7853cc4e689e0b93aeb3db18c09d82",
    "0x67dddf2673b69e5f875f6f25277495834398eafd67f492e09f3f3345e003d1b5"
  ],
  cere: [
    "0x81443836a9a24caaa23f1241897d1235717535711d1d3fe24eae4fdc942c092c"
  ],
  composable: [
    "0xdaab8df776eb52ec604a5df5d388bb62a050a0aaec4556a64265b9d42755552d"
  ],
  creditcoin3: [
    "0x4436a7d64e363df85e065a894721002a86643283f9707338bf195d360ba2ee71",
    // cc3 mainnet
    "0xfc4ec97a1c1f119c4353aecb4a17c7c0cf7b40d5d660143d8bad9117e9866572",
    // cc3 testnet/drynet
    "0xfc9df99a665f964aed6649f275055e54df5e3420489538ed31d7788f53d11ef6"
    // cc3 devnet
  ],
  darwinia: [
    "0xe71578b37a7c799b0ab4ee87ffa6f059a6b98f71f06fb8c84a8d88013a548ad6"
  ],
  dentnet: [
    "0x0313f6a011d128d22f996703cbab05162e2fdc9e031493314fe6db79979c5ca7"
  ],
  "dock-mainnet": [
    "0x6bfe24dca2a3be10f22212678ac13a6446ec764103c0f3471c71609eac384aae",
    "0xf73467c6544aa68df2ee546b135f955c46b90fa627e9b5d7935f41061bb8a5a9"
  ],
  edgeware: [
    "0x742a2ca70c2fda6cee4f8df98d64c4c670a052d9568058982dad9d5a7a135c5b"
  ],
  encointer: [
    "0x7dd99936c1e9e6d1ce7d90eb6f33bea8393b4bf87677d675aa63c9cb3e8c5b5b"
  ],
  enjin: [
    "0xd8761d3c88f26dc12875c00d3165f7d67243d56fc85b4cf19937601a7916e5a9"
  ],
  equilibrium: [
    "0x6f1a800de3daff7f5e037ddf66ab22ce03ab91874debeddb1086f5f7dbd48925"
  ],
  frequency: [
    "0x4a587bf17a404e3572747add7aab7bbe56e805a5479c6c436f07f36fcc8d3ae1"
  ],
  genshiro: [
    "0x9b8cefc0eb5c568b527998bdd76c184e2b76ae561be76e4667072230217ea243"
  ],
  hydradx: [
    "0xafdc188f45c71dacbaa0b62e16a91f726c7b8699a9748cdf715459de6b7f366d",
    // Hydration | HydraDX Parachain
    "0xd2a620c27ec5cbc5621ff9a522689895074f7cca0d08e7134a7804e1a3ba86fc",
    // Snakenet Gen3-1
    "0x10af6e84234477d84dc572bac0789813b254aa490767ed06fb9591191d1073f9",
    // Snakenet Gen3
    "0x3d75507dd46301767e601265791da1d9cb47b6ebc94e87347b635e5bf58bd047",
    // Snakenet Gen2
    "0x0ed32bfcab4a83517fac88f2aa7cbc2f88d3ab93be9a12b6188a036bf8a943c2"
    // Snakenet Gen1
  ],
  integritee: [
    "0xcdedc8eadbfa209d3f207bba541e57c3c58a667b05a2e1d1e86353c9000758da",
    // on Kusama
    "0xe13e7af377c64e83f95e0d70d5e5c3c01d697a84538776c5b9bbe0e7d7b6034c"
    // on Polkadot
  ],
  "interlay-parachain": [
    "0xbf88efe70e9e0e916416e8bed61f2b45717f517d7f3523e33c7b001e5ffcbc72"
  ],
  karura: [
    "0xbaf5aabe40646d11f0ee8abbdc64f4a4b7674925cba08e4a05ff9ebed6e2126b"
  ],
  khala: [
    "0xd43540ba6d3eb4897c28a77d48cb5b729fea37603cbbfc7a86a73b72adb3be8d"
  ],
  kulupu: [
    "0xf7a99d3cb92853d00d5275c971c132c074636256583fee53b3bbe60d7b8769ba"
  ],
  kusama: [
    "0xb0a8d493285c2df73290dfb7e61f870f17b41801197a149ca93654499ea3dafe",
    // Kusama CC3,
    "0xe3777fa922cafbff200cadeaea1a76bd7898ad5b89f7848999058b50e715f636",
    // Kusama CC2
    "0x3fd7b9eb6a00376e5be61f01abb429ffb0b104be05eaff4d458da48fcd425baf"
    // Kusama CC1
  ],
  liberland: [
    "0x6bd89e052d67a45bb60a9a23e8581053d5e0d619f15cb9865946937e690c42d6"
  ],
  matrixchain: [
    "0x3af4ff48ec76d2efc8476730f423ac07e25ad48f5f4c9dc39c778b164d808615"
  ],
  mythos: [
    "0xf6ee56e9c5277df5b4ce6ae9983ee88f3cbed27d31beeb98f9f84f997a1ab0b9"
  ],
  nodle: [
    "0x97da7ede98d7bad4e36b4d734b6055425a3be036da2a332ea5a7037656427a21"
  ],
  origintrail: [
    "0xe7e0962324a3b86c83404dbea483f25fb5dab4c224791c81b756cfc948006174"
  ],
  p3d: [
    "0x6c5894837ad89b6d92b114a2fb3eafa8fe3d26a54848e3447015442cd6ef4e66"
  ],
  parallel: [
    "0xe61a41c53f5dcd0beb09df93b34402aada44cb05117b71059cce40a2723a4e97"
  ],
  peaq: [
    "0xd2a5d385932d1f650dae03ef8e2748983779ee342c614f80854d32b8cd8fa48c"
  ],
  pendulum: [
    "0x5d3c298622d5634ed019bf61ea4b71655030015bde9beb0d6a24743714462c86"
  ],
  phala: [
    "0x1bb969d85965e4bb5a651abbedf21a54b6b31a21f66b5401cc3f1e286268d736"
  ],
  picasso: [
    "0x6811a339673c9daa897944dcdac99c6e2939cc88245ed21951a0a3c9a2be75bc",
    "0xe8e7f0f4c4f5a00720b4821dbfddefea7490bcf0b19009961cc46957984e2c1c"
  ],
  polimec: [
    "0x7eb9354488318e7549c722669dcbdcdc526f1fef1420e7944667212f3601fdbd"
  ],
  polkadex: [
    "0x3920bcb4960a1eef5580cd5367ff3f430eef052774f78468852f7b9cb39f8a3c"
  ],
  polkadot: [
    "0x91b171bb158e2d3848fa23a9f1c25182fb8e20313b2c1eb49219da7a70ce90c3"
  ],
  polymesh: [
    "0x6fbd74e5e1d0a61d52ccfe9d4adaed16dd3a7caa37c6bc4d0c2fa12e8b2f4063"
  ],
  quartz: [
    "0xcd4d732201ebe5d6b014edda071c4203e16867305332301dc8d092044b28e554"
  ],
  rococo: [
    "0x6408de7737c59c238890533af25896a2c20608d8b380bb01029acb392781063e",
    "0xaaf2cd1b74b5f726895921259421b534124726263982522174147046b8827897",
    "0x037f5f3c8e67b314062025fc886fcd6238ea25a4a9b45dce8d246815c9ebe770",
    "0xc196f81260cf1686172b47a79cf002120735d7cb0eb1474e8adce56618456fff",
    "0xf6e9983c37baf68846fedafe21e56718790e39fb1c582abc408b81bc7b208f9a",
    "0x5fce687da39305dfe682b117f0820b319348e8bb37eb16cf34acbf6a202de9d9",
    "0xe7c3d5edde7db964317cd9b51a3a059d7cd99f81bdbce14990047354334c9779",
    "0x1611e1dbf0405379b861e2e27daa90f480b2e6d3682414a80835a52e8cb8a215",
    "0x343442f12fa715489a8714e79a7b264ea88c0d5b8c66b684a7788a516032f6b9",
    "0x78bcd530c6b3a068bc17473cf5d2aff9c287102bed9af3ae3c41c33b9d6c6147",
    "0x47381ee0697153d64404fc578392c8fd5cba9073391908f46c888498415647bd",
    "0x19c0e4fa8ab75f5ac7865e0b8f74ff91eb9a100d336f423cd013a8befba40299"
  ],
  sora: [
    "0x7e4e32d0feafd4f9c9414b0be86373f9a1efa904809b683453a9af6856d38ad5"
  ],
  stafi: [
    "0x290a4149f09ea0e402c74c1c7e96ae4239588577fe78932f94f5404c68243d80"
  ],
  statemine: [
    "0x48239ef607d7928874027a43a67689209727dfb3d3dc5e5b03a39bdc2eda771a"
  ],
  statemint: [
    "0x68d56f15f85d3136970ec16946040bc1752654e906147f7e43e9d539d7c3de2f"
  ],
  subsocial: [
    "0x0bd72c1c305172e1275278aaeb3f161e02eccb7a819e63f62d47bd53a28189f8"
  ],
  ternoa: [
    "0x6859c81ca95ef624c9dfe4dc6e3381c33e5d6509e35e147092bfbc780f777c4e"
  ],
  unique: [
    "0x84322d9cddbf35088f1e54e9a85c967a41a56a4f43445768125e61af166c7d31"
  ],
  vara: [
    "0xfe1b4c55fd4d668101126434206571a7838a8b6b93a6d1b95d607e78e6c53763"
  ],
  vtb: [
    "0x286bc8414c7000ce1d6ee6a834e29a54c1784814b76243eb77ed0b2c5573c60f",
    "0x7483b89572fb2bd687c7b9a93b242d0b237f9aba463aba07ec24503931038aaa"
  ],
  westend: [
    "0xe143f23803ac50e8f6f8e62695d1ce9e4e1d68aa36c1cd2cfd15340213f3423e"
  ],
  xxnetwork: [
    "0x50dd5d206917bf10502c68fb4d18a59fc8aa31586f4e8856b493e43544aa82aa"
  ],
  zeitgeist: [
    "0x1bf2a2ecb4a868de66ea8610f2ce7c8c43706561b6476031315f6640fe38e060"
  ]
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/defaults/icons.js
var knownIcon = {
  centrifuge: "polkadot",
  kusama: "polkadot",
  polkadot: "polkadot",
  sora: "polkadot",
  statemine: "polkadot",
  statemint: "polkadot",
  westmint: "polkadot"
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/defaults/ledger.js
var knownLedger = {
  acala: 787,
  ajuna: 354,
  "aleph-node": 643,
  astar: 810,
  bifrost: 788,
  "bifrost-kusama": 788,
  bittensor: 354,
  centrifuge: 747,
  composable: 354,
  creditcoin3: 354,
  darwinia: 354,
  dentnet: 734,
  "dock-mainnet": 594,
  edgeware: 523,
  encointer: 434,
  enjin: 1155,
  equilibrium: 99999997,
  frequency: 2091,
  genshiro: 99999996,
  hydradx: 354,
  integritee: 2015,
  "interlay-parachain": 354,
  karura: 686,
  khala: 434,
  kusama: 434,
  liberland: 767,
  matrixchain: 1155,
  mythos: 60,
  nodle: 1003,
  origintrail: 354,
  parallel: 354,
  peaq: 3338,
  pendulum: 354,
  phala: 354,
  picasso: 434,
  polimec: 3344,
  polkadex: 799,
  polkadot: 354,
  polymesh: 595,
  quartz: 631,
  sora: 617,
  stafi: 907,
  statemine: 434,
  // common-good on Kusama, shares derivation
  statemint: 354,
  // common-good on Polkadot, shares derivation
  ternoa: 995,
  unique: 661,
  vara: 4976,
  vtb: 694,
  xxnetwork: 1955,
  zeitgeist: 354
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/defaults/testnets.js
var knownTestnet = {
  "": true,
  // this is the default non-network entry
  "cess-testnet": true,
  "dock-testnet": true,
  jupiter: true,
  "mathchain-testnet": true,
  p3dt: true,
  subspace_testnet: true,
  "zero-alphaville": true
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/networks/interfaces.js
var UNSORTED = [0, 2, 42];
var TESTNETS = ["testnet"];
function toExpanded(o) {
  var _a, _b;
  const network = o.network || "";
  const nameParts = network.replace(/_/g, "-").split("-");
  const n = o;
  n.slip44 = knownLedger[network];
  n.hasLedgerSupport = !!n.slip44;
  n.genesisHash = knownGenesis[network] || [];
  n.icon = knownIcon[network] || "substrate";
  n.isTestnet = !!knownTestnet[network] || TESTNETS.includes(nameParts[nameParts.length - 1]);
  n.isIgnored = n.isTestnet || !(o.standardAccount && ((_a = o.decimals) == null ? void 0 : _a.length) && ((_b = o.symbols) == null ? void 0 : _b.length)) && o.prefix !== 42;
  return n;
}
function filterSelectable({ genesisHash, prefix }) {
  return !!genesisHash.length || prefix === 42;
}
function filterAvailable(n) {
  return !n.isIgnored && !!n.network;
}
function sortNetworks(a, b) {
  const isUnSortedA = UNSORTED.includes(a.prefix);
  const isUnSortedB = UNSORTED.includes(b.prefix);
  return isUnSortedA === isUnSortedB ? isUnSortedA ? 0 : a.displayName.localeCompare(b.displayName) : isUnSortedA ? -1 : 1;
}
var allNetworks = esm_default.map(toExpanded);
var availableNetworks = allNetworks.filter(filterAvailable).sort(sortNetworks);
var selectableNetworks = availableNetworks.filter(filterSelectable);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/defaults.js
var defaults = {
  allowedDecodedLengths: [1, 2, 4, 8, 32, 33],
  // publicKey has prefix + 2 checksum bytes, short only prefix + 1 checksum byte
  allowedEncodedLengths: [3, 4, 6, 10, 35, 36, 37, 38],
  allowedPrefix: availableNetworks.map(({ prefix }) => prefix),
  prefix: 42
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/decode.js
function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (!encoded) {
    throw new Error("Invalid empty address passed");
  }
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }
  try {
    const decoded = base58Decode(encoded);
    if (!defaults.allowedEncodedLengths.includes(decoded.length)) {
      throw new Error("Invalid decoded address length");
    }
    const [isValid, endPos, ss58Length, ss58Decoded] = checkAddressChecksum(decoded);
    if (!isValid && !ignoreChecksum) {
      throw new Error("Invalid decoded address checksum");
    } else if (ss58Format !== -1 && ss58Format !== ss58Decoded) {
      throw new Error(`Expected ss58Format ${ss58Format}, received ${ss58Decoded}`);
    }
    return decoded.slice(ss58Length, endPos);
  } catch (error) {
    throw new Error(`Decoding ${encoded}: ${error.message}`);
  }
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/bn.js
var BN_BE_256_OPTS = { bitLength: 256, isLe: false };

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/deriveHard.js
var HDKD = compactAddLength(stringToU8a("Secp256k1HDKD"));
function secp256k1DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD, seed, chainCode), 256);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/pair/fromSeed.js
function secp256k1PairFromSeed(seed, onlyJs) {
  if (seed.length !== 32) {
    throw new Error("Expected valid 32-byte private key as a seed");
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = secp256k1FromSeed(seed);
    const publicKey = full.slice(32);
    if (u8aEmpty(publicKey)) {
      throw new Error("Invalid publicKey generated from WASM interface");
    }
    return {
      publicKey,
      secretKey: full.slice(0, 32)
    };
  }
  return {
    publicKey: secp256k1.getPublicKey(seed, true),
    secretKey: seed
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/key/hdkdDerive.js
function createSeedDeriveFn(fromSeed, derive) {
  return (keypair, { chainCode, isHard }) => {
    if (!isHard) {
      throw new Error("A soft key was found in the path and is not supported");
    }
    return fromSeed(derive(keypair.secretKey.subarray(0, 32), chainCode));
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/key/hdkdEcdsa.js
var keyHdkdEcdsa = createSeedDeriveFn(secp256k1PairFromSeed, secp256k1DeriveHard);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/ed25519/deriveHard.js
var HDKD2 = compactAddLength(stringToU8a("Ed25519HDKD"));
function ed25519DeriveHard(seed, chainCode) {
  if (!isU8a(chainCode) || chainCode.length !== 32) {
    throw new Error("Invalid chainCode passed to derive");
  }
  return blake2AsU8a(u8aConcat(HDKD2, seed, chainCode));
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/random/asU8a.js
function randomAsU8a(length = 32) {
  return getRandomValues(new Uint8Array(length));
}
var randomAsHex = createAsHex(randomAsU8a);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/random/asNumber.js
var BN_53 = new import_bn.default(9007199254740991);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/ed25519/pair/fromSeed.js
function ed25519PairFromSeed(seed, onlyJs) {
  if (!hasBigInt || !onlyJs && isReady()) {
    const full = ed25519KeypairFromSeed(seed);
    return {
      publicKey: full.slice(32),
      secretKey: full.slice(0, 64)
    };
  }
  const publicKey = ed25519.getPublicKey(seed);
  return {
    publicKey,
    secretKey: u8aConcatStrict([seed, publicKey])
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/key/hdkdEd25519.js
var keyHdkdEd25519 = createSeedDeriveFn(ed25519PairFromSeed, ed25519DeriveHard);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/pair/fromU8a.js
var SEC_LEN = 64;
var PUB_LEN = 32;
var TOT_LEN = SEC_LEN + PUB_LEN;
function sr25519PairFromU8a(full) {
  const fullU8a = u8aToU8a(full);
  if (fullU8a.length !== TOT_LEN) {
    throw new Error(`Expected keypair with ${TOT_LEN} bytes, found ${fullU8a.length}`);
  }
  return {
    publicKey: fullU8a.slice(SEC_LEN, TOT_LEN),
    secretKey: fullU8a.slice(0, SEC_LEN)
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/pair/toU8a.js
function sr25519KeypairToU8a({ publicKey, secretKey }) {
  return u8aConcat(secretKey, publicKey).slice();
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/derive.js
function createDeriveFn(derive) {
  return (keypair, chainCode) => {
    if (!isU8a(chainCode) || chainCode.length !== 32) {
      throw new Error("Invalid chainCode passed to derive");
    }
    return sr25519PairFromU8a(derive(sr25519KeypairToU8a(keypair), chainCode));
  };
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/deriveHard.js
var sr25519DeriveHard = createDeriveFn(sr25519DeriveKeypairHard);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/deriveSoft.js
var sr25519DeriveSoft = createDeriveFn(sr25519DeriveKeypairSoft);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/vrfSign.js
var EMPTY_U8A = new Uint8Array();

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sr25519/vrfVerify.js
var EMPTY_U8A2 = new Uint8Array();

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/encode.js
function encodeAddress(key, ss58Format = defaults.prefix) {
  const u8a = decodeAddress(key);
  if (ss58Format < 0 || ss58Format > 16383 && !ss58Exceptions.includes(ss58Format) || [46, 47].includes(ss58Format)) {
    throw new Error("Out of range ss58Format specified");
  } else if (!defaults.allowedDecodedLengths.includes(u8a.length)) {
    throw new Error(`Expected a valid key to convert, with length ${defaults.allowedDecodedLengths.join(", ")}`);
  }
  const input = u8aConcat(ss58Format < 64 ? [ss58Format] : [
    (ss58Format & 252) >> 2 | 64,
    ss58Format >> 8 | (ss58Format & 3) << 6
  ], u8a);
  return base58Encode(u8aConcat(input, sshash(input).subarray(0, [32, 33].includes(u8a.length) ? 2 : 1)));
}
var ss58Exceptions = [29972];

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/keyDerived.js
var PREFIX = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/keyMulti.js
var PREFIX2 = stringToU8a("modlpy/utilisuba");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/keccak/asU8a.js
var keccakAsU8a = createDualHasher({ 256: keccak256, 512: keccak512 }, { 256: keccak_256, 512: keccak_512 });
var keccak256AsU8a = createBitHasher(256, keccakAsU8a);
var keccak512AsU8a = createBitHasher(512, keccakAsU8a);
var keccakAsHex = createAsHex(keccakAsU8a);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/hasher.js
function hasher(hashType, data, onlyJs) {
  return hashType === "keccak" ? keccakAsU8a(data, void 0, onlyJs) : blake2AsU8a(data, void 0, void 0, onlyJs);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/address/setSS58Format.js
var l = logger("setSS58Format");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/base32/bs32.js
var chars = "abcdefghijklmnopqrstuvwxyz234567";
var config2 = {
  chars,
  coder: utils.chain(
    // We define our own chain, the default base32 has padding
    utils.radix2(5),
    utils.alphabet(chars),
    {
      decode: (input) => input.split(""),
      encode: (input) => input.join("")
    }
  ),
  ipfs: "b",
  type: "base32"
};
var base32Validate = createValidate(config2);
var isBase32 = createIs(base32Validate);
var base32Decode = createDecode(config2, base32Validate);
var base32Encode = createEncode(config2);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/base64/bs64.js
var config3 = {
  chars: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
  coder: base64,
  type: "base64",
  withPadding: true
};
var base64Validate = createValidate(config3);
var isBase64 = createIs(base64Validate);
var base64Decode = createDecode(config3, base64Validate);
var base64Encode = createEncode(config3);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/compress.js
function secp256k1Compress2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 33) {
    return publicKey;
  }
  return !hasBigInt || !onlyJs && isReady() ? secp256k1Compress(publicKey) : secp256k1.ProjectivePoint.fromHex(publicKey).toRawBytes(true);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/expand.js
function secp256k1Expand2(publicKey, onlyJs) {
  if (![33, 65].includes(publicKey.length)) {
    throw new Error(`Invalid publicKey provided, received ${publicKey.length} bytes input`);
  }
  if (publicKey.length === 65) {
    return publicKey.subarray(1);
  }
  if (!hasBigInt || !onlyJs && isReady()) {
    return secp256k1Expand(publicKey).subarray(1);
  }
  const { px, py } = secp256k1.ProjectivePoint.fromHex(publicKey);
  return u8aConcat(bnToU8a(px, BN_BE_256_OPTS), bnToU8a(py, BN_BE_256_OPTS));
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/recover.js
function secp256k1Recover2(msgHash, signature, recovery, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature).subarray(0, 64);
  const msg = u8aToU8a(msgHash);
  const publicKey = !hasBigInt || !onlyJs && isReady() ? secp256k1Recover(msg, sig, recovery) : secp256k1.Signature.fromCompact(sig).addRecoveryBit(recovery).recoverPublicKey(msg).toRawBytes();
  if (!publicKey) {
    throw new Error("Unable to recover publicKey from signature");
  }
  return hashType === "keccak" ? secp256k1Expand2(publicKey, onlyJs) : secp256k1Compress2(publicKey, onlyJs);
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/tweakAdd.js
var N = "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141".replace(/ /g, "");
var N_BI = BigInt(`0x${N}`);
var N_BN = new import_bn.default(N, "hex");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/secp256k1/verify.js
function secp256k1Verify(msgHash, signature, address, hashType = "blake2", onlyJs) {
  const sig = u8aToU8a(signature);
  if (sig.length !== 65) {
    throw new Error(`Expected signature with 65 bytes, ${sig.length} found instead`);
  }
  const publicKey = secp256k1Recover2(hasher(hashType, msgHash), sig, sig[64], hashType, onlyJs);
  const signerAddr = hasher(hashType, publicKey, onlyJs);
  const inputAddr = u8aToU8a(address);
  return u8aEq(publicKey, inputAddr) || (hashType === "keccak" ? u8aEq(signerAddr.slice(-20), inputAddr.slice(-20)) : u8aEq(signerAddr, inputAddr));
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/hmac/shaAsU8a.js
var JS_HASH = {
  256: sha2562,
  512: sha5122
};
var WA_MHAC = {
  256: hmacSha256,
  512: hmacSha512
};
function createSha(bitLength) {
  return (key, data, onlyJs) => hmacShaAsU8a(key, data, bitLength, onlyJs);
}
function hmacShaAsU8a(key, data, bitLength = 256, onlyJs) {
  const u8aKey = u8aToU8a(key);
  return !hasBigInt || !onlyJs && isReady() ? WA_MHAC[bitLength](u8aKey, data) : hmac(JS_HASH[bitLength], u8aKey, data);
}
var hmacSha256AsU8a = createSha(256);
var hmacSha512AsU8a = createSha(512);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/hd/ethereum/index.js
var MASTER_SECRET = stringToU8a("Bitcoin seed");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/sha/asU8a.js
var shaAsU8a = createDualHasher({ 256: sha256, 512: sha512 }, { 256: sha2562, 512: sha5122 });
var sha256AsU8a = createBitHasher(256, shaAsU8a);
var sha512AsU8a = createBitHasher(512, shaAsU8a);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/mnemonic/wordlists/en.js
var en_default = "abandon|ability|able|about|above|absent|absorb|abstract|absurd|abuse|access|accident|account|accuse|achieve|acid|acoustic|acquire|across|act|action|actor|actress|actual|adapt|add|addict|address|adjust|admit|adult|advance|advice|aerobic|affair|afford|afraid|again|age|agent|agree|ahead|aim|air|airport|aisle|alarm|album|alcohol|alert|alien|all|alley|allow|almost|alone|alpha|already|also|alter|always|amateur|amazing|among|amount|amused|analyst|anchor|ancient|anger|angle|angry|animal|ankle|announce|annual|another|answer|antenna|antique|anxiety|any|apart|apology|appear|apple|approve|april|arch|arctic|area|arena|argue|arm|armed|armor|army|around|arrange|arrest|arrive|arrow|art|artefact|artist|artwork|ask|aspect|assault|asset|assist|assume|asthma|athlete|atom|attack|attend|attitude|attract|auction|audit|august|aunt|author|auto|autumn|average|avocado|avoid|awake|aware|away|awesome|awful|awkward|axis|baby|bachelor|bacon|badge|bag|balance|balcony|ball|bamboo|banana|banner|bar|barely|bargain|barrel|base|basic|basket|battle|beach|bean|beauty|because|become|beef|before|begin|behave|behind|believe|below|belt|bench|benefit|best|betray|better|between|beyond|bicycle|bid|bike|bind|biology|bird|birth|bitter|black|blade|blame|blanket|blast|bleak|bless|blind|blood|blossom|blouse|blue|blur|blush|board|boat|body|boil|bomb|bone|bonus|book|boost|border|boring|borrow|boss|bottom|bounce|box|boy|bracket|brain|brand|brass|brave|bread|breeze|brick|bridge|brief|bright|bring|brisk|broccoli|broken|bronze|broom|brother|brown|brush|bubble|buddy|budget|buffalo|build|bulb|bulk|bullet|bundle|bunker|burden|burger|burst|bus|business|busy|butter|buyer|buzz|cabbage|cabin|cable|cactus|cage|cake|call|calm|camera|camp|can|canal|cancel|candy|cannon|canoe|canvas|canyon|capable|capital|captain|car|carbon|card|cargo|carpet|carry|cart|case|cash|casino|castle|casual|cat|catalog|catch|category|cattle|caught|cause|caution|cave|ceiling|celery|cement|census|century|cereal|certain|chair|chalk|champion|change|chaos|chapter|charge|chase|chat|cheap|check|cheese|chef|cherry|chest|chicken|chief|child|chimney|choice|choose|chronic|chuckle|chunk|churn|cigar|cinnamon|circle|citizen|city|civil|claim|clap|clarify|claw|clay|clean|clerk|clever|click|client|cliff|climb|clinic|clip|clock|clog|close|cloth|cloud|clown|club|clump|cluster|clutch|coach|coast|coconut|code|coffee|coil|coin|collect|color|column|combine|come|comfort|comic|common|company|concert|conduct|confirm|congress|connect|consider|control|convince|cook|cool|copper|copy|coral|core|corn|correct|cost|cotton|couch|country|couple|course|cousin|cover|coyote|crack|cradle|craft|cram|crane|crash|crater|crawl|crazy|cream|credit|creek|crew|cricket|crime|crisp|critic|crop|cross|crouch|crowd|crucial|cruel|cruise|crumble|crunch|crush|cry|crystal|cube|culture|cup|cupboard|curious|current|curtain|curve|cushion|custom|cute|cycle|dad|damage|damp|dance|danger|daring|dash|daughter|dawn|day|deal|debate|debris|decade|december|decide|decline|decorate|decrease|deer|defense|define|defy|degree|delay|deliver|demand|demise|denial|dentist|deny|depart|depend|deposit|depth|deputy|derive|describe|desert|design|desk|despair|destroy|detail|detect|develop|device|devote|diagram|dial|diamond|diary|dice|diesel|diet|differ|digital|dignity|dilemma|dinner|dinosaur|direct|dirt|disagree|discover|disease|dish|dismiss|disorder|display|distance|divert|divide|divorce|dizzy|doctor|document|dog|doll|dolphin|domain|donate|donkey|donor|door|dose|double|dove|draft|dragon|drama|drastic|draw|dream|dress|drift|drill|drink|drip|drive|drop|drum|dry|duck|dumb|dune|during|dust|dutch|duty|dwarf|dynamic|eager|eagle|early|earn|earth|easily|east|easy|echo|ecology|economy|edge|edit|educate|effort|egg|eight|either|elbow|elder|electric|elegant|element|elephant|elevator|elite|else|embark|embody|embrace|emerge|emotion|employ|empower|empty|enable|enact|end|endless|endorse|enemy|energy|enforce|engage|engine|enhance|enjoy|enlist|enough|enrich|enroll|ensure|enter|entire|entry|envelope|episode|equal|equip|era|erase|erode|erosion|error|erupt|escape|essay|essence|estate|eternal|ethics|evidence|evil|evoke|evolve|exact|example|excess|exchange|excite|exclude|excuse|execute|exercise|exhaust|exhibit|exile|exist|exit|exotic|expand|expect|expire|explain|expose|express|extend|extra|eye|eyebrow|fabric|face|faculty|fade|faint|faith|fall|false|fame|family|famous|fan|fancy|fantasy|farm|fashion|fat|fatal|father|fatigue|fault|favorite|feature|february|federal|fee|feed|feel|female|fence|festival|fetch|fever|few|fiber|fiction|field|figure|file|film|filter|final|find|fine|finger|finish|fire|firm|first|fiscal|fish|fit|fitness|fix|flag|flame|flash|flat|flavor|flee|flight|flip|float|flock|floor|flower|fluid|flush|fly|foam|focus|fog|foil|fold|follow|food|foot|force|forest|forget|fork|fortune|forum|forward|fossil|foster|found|fox|fragile|frame|frequent|fresh|friend|fringe|frog|front|frost|frown|frozen|fruit|fuel|fun|funny|furnace|fury|future|gadget|gain|galaxy|gallery|game|gap|garage|garbage|garden|garlic|garment|gas|gasp|gate|gather|gauge|gaze|general|genius|genre|gentle|genuine|gesture|ghost|giant|gift|giggle|ginger|giraffe|girl|give|glad|glance|glare|glass|glide|glimpse|globe|gloom|glory|glove|glow|glue|goat|goddess|gold|good|goose|gorilla|gospel|gossip|govern|gown|grab|grace|grain|grant|grape|grass|gravity|great|green|grid|grief|grit|grocery|group|grow|grunt|guard|guess|guide|guilt|guitar|gun|gym|habit|hair|half|hammer|hamster|hand|happy|harbor|hard|harsh|harvest|hat|have|hawk|hazard|head|health|heart|heavy|hedgehog|height|hello|helmet|help|hen|hero|hidden|high|hill|hint|hip|hire|history|hobby|hockey|hold|hole|holiday|hollow|home|honey|hood|hope|horn|horror|horse|hospital|host|hotel|hour|hover|hub|huge|human|humble|humor|hundred|hungry|hunt|hurdle|hurry|hurt|husband|hybrid|ice|icon|idea|identify|idle|ignore|ill|illegal|illness|image|imitate|immense|immune|impact|impose|improve|impulse|inch|include|income|increase|index|indicate|indoor|industry|infant|inflict|inform|inhale|inherit|initial|inject|injury|inmate|inner|innocent|input|inquiry|insane|insect|inside|inspire|install|intact|interest|into|invest|invite|involve|iron|island|isolate|issue|item|ivory|jacket|jaguar|jar|jazz|jealous|jeans|jelly|jewel|job|join|joke|journey|joy|judge|juice|jump|jungle|junior|junk|just|kangaroo|keen|keep|ketchup|key|kick|kid|kidney|kind|kingdom|kiss|kit|kitchen|kite|kitten|kiwi|knee|knife|knock|know|lab|label|labor|ladder|lady|lake|lamp|language|laptop|large|later|latin|laugh|laundry|lava|law|lawn|lawsuit|layer|lazy|leader|leaf|learn|leave|lecture|left|leg|legal|legend|leisure|lemon|lend|length|lens|leopard|lesson|letter|level|liar|liberty|library|license|life|lift|light|like|limb|limit|link|lion|liquid|list|little|live|lizard|load|loan|lobster|local|lock|logic|lonely|long|loop|lottery|loud|lounge|love|loyal|lucky|luggage|lumber|lunar|lunch|luxury|lyrics|machine|mad|magic|magnet|maid|mail|main|major|make|mammal|man|manage|mandate|mango|mansion|manual|maple|marble|march|margin|marine|market|marriage|mask|mass|master|match|material|math|matrix|matter|maximum|maze|meadow|mean|measure|meat|mechanic|medal|media|melody|melt|member|memory|mention|menu|mercy|merge|merit|merry|mesh|message|metal|method|middle|midnight|milk|million|mimic|mind|minimum|minor|minute|miracle|mirror|misery|miss|mistake|mix|mixed|mixture|mobile|model|modify|mom|moment|monitor|monkey|monster|month|moon|moral|more|morning|mosquito|mother|motion|motor|mountain|mouse|move|movie|much|muffin|mule|multiply|muscle|museum|mushroom|music|must|mutual|myself|mystery|myth|naive|name|napkin|narrow|nasty|nation|nature|near|neck|need|negative|neglect|neither|nephew|nerve|nest|net|network|neutral|never|news|next|nice|night|noble|noise|nominee|noodle|normal|north|nose|notable|note|nothing|notice|novel|now|nuclear|number|nurse|nut|oak|obey|object|oblige|obscure|observe|obtain|obvious|occur|ocean|october|odor|off|offer|office|often|oil|okay|old|olive|olympic|omit|once|one|onion|online|only|open|opera|opinion|oppose|option|orange|orbit|orchard|order|ordinary|organ|orient|original|orphan|ostrich|other|outdoor|outer|output|outside|oval|oven|over|own|owner|oxygen|oyster|ozone|pact|paddle|page|pair|palace|palm|panda|panel|panic|panther|paper|parade|parent|park|parrot|party|pass|patch|path|patient|patrol|pattern|pause|pave|payment|peace|peanut|pear|peasant|pelican|pen|penalty|pencil|people|pepper|perfect|permit|person|pet|phone|photo|phrase|physical|piano|picnic|picture|piece|pig|pigeon|pill|pilot|pink|pioneer|pipe|pistol|pitch|pizza|place|planet|plastic|plate|play|please|pledge|pluck|plug|plunge|poem|poet|point|polar|pole|police|pond|pony|pool|popular|portion|position|possible|post|potato|pottery|poverty|powder|power|practice|praise|predict|prefer|prepare|present|pretty|prevent|price|pride|primary|print|priority|prison|private|prize|problem|process|produce|profit|program|project|promote|proof|property|prosper|protect|proud|provide|public|pudding|pull|pulp|pulse|pumpkin|punch|pupil|puppy|purchase|purity|purpose|purse|push|put|puzzle|pyramid|quality|quantum|quarter|question|quick|quit|quiz|quote|rabbit|raccoon|race|rack|radar|radio|rail|rain|raise|rally|ramp|ranch|random|range|rapid|rare|rate|rather|raven|raw|razor|ready|real|reason|rebel|rebuild|recall|receive|recipe|record|recycle|reduce|reflect|reform|refuse|region|regret|regular|reject|relax|release|relief|rely|remain|remember|remind|remove|render|renew|rent|reopen|repair|repeat|replace|report|require|rescue|resemble|resist|resource|response|result|retire|retreat|return|reunion|reveal|review|reward|rhythm|rib|ribbon|rice|rich|ride|ridge|rifle|right|rigid|ring|riot|ripple|risk|ritual|rival|river|road|roast|robot|robust|rocket|romance|roof|rookie|room|rose|rotate|rough|round|route|royal|rubber|rude|rug|rule|run|runway|rural|sad|saddle|sadness|safe|sail|salad|salmon|salon|salt|salute|same|sample|sand|satisfy|satoshi|sauce|sausage|save|say|scale|scan|scare|scatter|scene|scheme|school|science|scissors|scorpion|scout|scrap|screen|script|scrub|sea|search|season|seat|second|secret|section|security|seed|seek|segment|select|sell|seminar|senior|sense|sentence|series|service|session|settle|setup|seven|shadow|shaft|shallow|share|shed|shell|sheriff|shield|shift|shine|ship|shiver|shock|shoe|shoot|shop|short|shoulder|shove|shrimp|shrug|shuffle|shy|sibling|sick|side|siege|sight|sign|silent|silk|silly|silver|similar|simple|since|sing|siren|sister|situate|six|size|skate|sketch|ski|skill|skin|skirt|skull|slab|slam|sleep|slender|slice|slide|slight|slim|slogan|slot|slow|slush|small|smart|smile|smoke|smooth|snack|snake|snap|sniff|snow|soap|soccer|social|sock|soda|soft|solar|soldier|solid|solution|solve|someone|song|soon|sorry|sort|soul|sound|soup|source|south|space|spare|spatial|spawn|speak|special|speed|spell|spend|sphere|spice|spider|spike|spin|spirit|split|spoil|sponsor|spoon|sport|spot|spray|spread|spring|spy|square|squeeze|squirrel|stable|stadium|staff|stage|stairs|stamp|stand|start|state|stay|steak|steel|stem|step|stereo|stick|still|sting|stock|stomach|stone|stool|story|stove|strategy|street|strike|strong|struggle|student|stuff|stumble|style|subject|submit|subway|success|such|sudden|suffer|sugar|suggest|suit|summer|sun|sunny|sunset|super|supply|supreme|sure|surface|surge|surprise|surround|survey|suspect|sustain|swallow|swamp|swap|swarm|swear|sweet|swift|swim|swing|switch|sword|symbol|symptom|syrup|system|table|tackle|tag|tail|talent|talk|tank|tape|target|task|taste|tattoo|taxi|teach|team|tell|ten|tenant|tennis|tent|term|test|text|thank|that|theme|then|theory|there|they|thing|this|thought|three|thrive|throw|thumb|thunder|ticket|tide|tiger|tilt|timber|time|tiny|tip|tired|tissue|title|toast|tobacco|today|toddler|toe|together|toilet|token|tomato|tomorrow|tone|tongue|tonight|tool|tooth|top|topic|topple|torch|tornado|tortoise|toss|total|tourist|toward|tower|town|toy|track|trade|traffic|tragic|train|transfer|trap|trash|travel|tray|treat|tree|trend|trial|tribe|trick|trigger|trim|trip|trophy|trouble|truck|true|truly|trumpet|trust|truth|try|tube|tuition|tumble|tuna|tunnel|turkey|turn|turtle|twelve|twenty|twice|twin|twist|two|type|typical|ugly|umbrella|unable|unaware|uncle|uncover|under|undo|unfair|unfold|unhappy|uniform|unique|unit|universe|unknown|unlock|until|unusual|unveil|update|upgrade|uphold|upon|upper|upset|urban|urge|usage|use|used|useful|useless|usual|utility|vacant|vacuum|vague|valid|valley|valve|van|vanish|vapor|various|vast|vault|vehicle|velvet|vendor|venture|venue|verb|verify|version|very|vessel|veteran|viable|vibrant|vicious|victory|video|view|village|vintage|violin|virtual|virus|visa|visit|visual|vital|vivid|vocal|voice|void|volcano|volume|vote|voyage|wage|wagon|wait|walk|wall|walnut|want|warfare|warm|warrior|wash|wasp|waste|water|wave|way|wealth|weapon|wear|weasel|weather|web|wedding|weekend|weird|welcome|west|wet|whale|what|wheat|wheel|when|where|whip|whisper|wide|width|wife|wild|will|win|window|wine|wing|wink|winner|winter|wire|wisdom|wise|wish|witness|wolf|woman|wonder|wood|wool|word|work|world|worry|worth|wrap|wreck|wrestle|wrist|write|wrong|yard|year|yellow|you|young|youth|zebra|zero|zone|zoo".split("|");

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/nacl/tweetnacl.js
var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
var minusp = new Uint32Array([5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 252]);

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/scrypt/defaults.js
var ALLOWED_PARAMS = [
  { N: 1 << 13, p: 10, r: 8 },
  { N: 1 << 14, p: 5, r: 8 },
  { N: 1 << 15, p: 3, r: 8 },
  { N: 1 << 15, p: 1, r: 8 },
  { N: 1 << 16, p: 2, r: 8 },
  { N: 1 << 17, p: 1, r: 8 }
];
var DEFAULT_PARAMS = {
  N: 1 << 17,
  p: 1,
  r: 8
};

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/json/constants.js
var SCRYPT_LENGTH = 32 + 3 * 4;

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/signature/verify.js
var secp256k1VerifyHasher = (hashType) => (message, signature, publicKey) => secp256k1Verify(message, signature, publicKey, hashType, true);
var VERIFIERS_ECDSA = [
  ["ecdsa", secp256k1VerifyHasher("blake2")],
  ["ethereum", secp256k1VerifyHasher("keccak")]
];

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/xxhash/xxhash64.js
var P64_1 = BigInt("11400714785074694791");
var P64_2 = BigInt("14029467366897019727");
var P64_3 = BigInt("1609587929392839161");
var P64_4 = BigInt("9650029242287828579");
var P64_5 = BigInt("2870177450012600261");
var U64 = BigInt("0xffffffffffffffff");
var _7n2 = BigInt(7);
var _11n = BigInt(11);
var _12n = BigInt(12);
var _16n = BigInt(16);
var _18n = BigInt(18);
var _23n = BigInt(23);
var _27n = BigInt(27);
var _29n = BigInt(29);
var _31n = BigInt(31);
var _32n = BigInt(32);
var _33n = BigInt(33);
var _64n = BigInt(64);
var _256n = BigInt(256);
function rotl(a, b) {
  const c = a & U64;
  return (c << b | c >> _64n - b) & U64;
}
function fromU8a(u8a, p, count) {
  const bigints = new Array(count);
  let offset = 0;
  for (let i = 0; i < count; i++, offset += 2) {
    bigints[i] = BigInt(u8a[p + offset] | u8a[p + 1 + offset] << 8);
  }
  let result = _0n;
  for (let i = count - 1; i >= 0; i--) {
    result = (result << _16n) + bigints[i];
  }
  return result;
}
function init(seed, input) {
  const state = {
    seed,
    u8a: new Uint8Array(32),
    u8asize: 0,
    v1: seed + P64_1 + P64_2,
    v2: seed + P64_2,
    v3: seed,
    v4: seed - P64_1
  };
  if (input.length < 32) {
    state.u8a.set(input);
    state.u8asize = input.length;
    return state;
  }
  const limit = input.length - 32;
  let p = 0;
  if (limit >= 0) {
    const adjustV = (v) => P64_1 * rotl(v + P64_2 * fromU8a(input, p, 4), _31n);
    do {
      state.v1 = adjustV(state.v1);
      p += 8;
      state.v2 = adjustV(state.v2);
      p += 8;
      state.v3 = adjustV(state.v3);
      p += 8;
      state.v4 = adjustV(state.v4);
      p += 8;
    } while (p <= limit);
  }
  if (p < input.length) {
    state.u8a.set(input.subarray(p, input.length));
    state.u8asize = input.length - p;
  }
  return state;
}
function xxhash64(input, initSeed) {
  const { seed, u8a, u8asize, v1, v2, v3, v4: v42 } = init(BigInt(initSeed), input);
  let p = 0;
  let h64 = U64 & BigInt(input.length) + (input.length >= 32 ? ((((rotl(v1, _1n) + rotl(v2, _7n2) + rotl(v3, _12n) + rotl(v42, _18n) ^ P64_1 * rotl(v1 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v2 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v3 * P64_2, _31n)) * P64_1 + P64_4 ^ P64_1 * rotl(v42 * P64_2, _31n)) * P64_1 + P64_4 : seed + P64_5);
  while (p <= u8asize - 8) {
    h64 = U64 & P64_4 + P64_1 * rotl(h64 ^ P64_1 * rotl(P64_2 * fromU8a(u8a, p, 4), _31n), _27n);
    p += 8;
  }
  if (p + 4 <= u8asize) {
    h64 = U64 & P64_3 + P64_2 * rotl(h64 ^ P64_1 * fromU8a(u8a, p, 2), _23n);
    p += 4;
  }
  while (p < u8asize) {
    h64 = U64 & P64_1 * rotl(h64 ^ P64_5 * BigInt(u8a[p++]), _11n);
  }
  h64 = U64 & P64_2 * (h64 ^ h64 >> _33n);
  h64 = U64 & P64_3 * (h64 ^ h64 >> _29n);
  h64 = U64 & (h64 ^ h64 >> _32n);
  const result = new Uint8Array(8);
  for (let i = 7; i >= 0; i--) {
    result[i] = Number(h64 % _256n);
    h64 = h64 / _256n;
  }
  return result;
}

// node_modules/@polkadot/extension-dapp/node_modules/@polkadot/util-crypto/xxhash/asU8a.js
function xxhashAsU8a(data, bitLength = 64, onlyJs) {
  const rounds = Math.ceil(bitLength / 64);
  const u8a = u8aToU8a(data);
  if (!hasBigInt || !onlyJs && isReady()) {
    return twox(u8a, rounds);
  }
  const result = new Uint8Array(rounds * 8);
  for (let seed = 0; seed < rounds; seed++) {
    result.set(xxhash64(u8a, seed).reverse(), seed * 8);
  }
  return result;
}
var xxhashAsHex = createAsHex(xxhashAsU8a);

// node_modules/@polkadot/extension-dapp/util.js
function documentReadyPromise(creator) {
  return new Promise((resolve) => {
    if (document.readyState === "complete") {
      resolve(creator());
    } else {
      window.addEventListener("load", () => resolve(creator()));
    }
  });
}

// node_modules/@polkadot/extension-dapp/packageInfo.js
var packageInfo9 = { name: "@polkadot/extension-dapp", path: import.meta && import.meta.url ? new URL(import.meta.url).pathname.substring(0, new URL(import.meta.url).pathname.lastIndexOf("/") + 1) : "auto", type: "esm", version: "0.62.6" };

// node_modules/@polkadot/extension-dapp/wrapBytes.js
var unwrapBytes = u8aUnwrapBytes;
var wrapBytes = u8aWrapBytes;

// node_modules/@polkadot/extension-dapp/bundle.js
var win = window;
win.injectedWeb3 = win.injectedWeb3 || {};
var isWeb3Injected = web3IsInjected();
var web3EnablePromise = null;
function web3IsInjected() {
  return Object.values(win.injectedWeb3).filter(({ connect, enable }) => !!(connect || enable)).length !== 0;
}
function throwError(method) {
  throw new Error(`${method}: web3Enable(originName) needs to be called before ${method}`);
}
function mapAccounts(source, list, ss58Format) {
  return list.map(({ address, genesisHash, name, type }) => ({
    address: address.length === 42 ? address : encodeAddress(decodeAddress(address), ss58Format),
    meta: { genesisHash, name, source },
    type
  }));
}
function filterAccounts(list, genesisHash, type) {
  return list.filter((a) => (!a.type || !type || type.includes(a.type)) && (!a.genesisHash || !genesisHash || a.genesisHash === genesisHash));
}
function getWindowExtensions(originName) {
  return Promise.all(Object.entries(win.injectedWeb3).map(([nameOrHash, { connect, enable, version }]) => Promise.resolve().then(() => connect ? connect(originName) : enable ? enable(originName).then((e) => objectSpread({ name: nameOrHash, version: version || "unknown" }, e)) : Promise.reject(new Error("No connect(..) or enable(...) hook found"))).catch(({ message }) => {
    console.error(`Error initializing ${nameOrHash}: ${message}`);
  }))).then((exts) => exts.filter((e) => !!e));
}
async function filterEnable(caller, extensions) {
  if (!web3EnablePromise) {
    return throwError(caller);
  }
  const sources = await web3EnablePromise;
  return sources.filter(({ name }) => !extensions || extensions.includes(name));
}
function web3Enable(originName, compatInits = []) {
  if (!originName) {
    throw new Error("You must pass a name for your app to the web3Enable function");
  }
  const initCompat = compatInits.length ? Promise.all(compatInits.map((c) => c().catch(() => false))) : Promise.resolve([true]);
  web3EnablePromise = documentReadyPromise(() => initCompat.then(() => getWindowExtensions(originName).then((values) => values.map((e) => {
    if (!e.accounts.subscribe) {
      e.accounts.subscribe = (cb) => {
        e.accounts.get().then(cb).catch(console.error);
        return () => {
        };
      };
    }
    return e;
  })).catch(() => []).then((values) => {
    const names = values.map(({ name, version }) => `${name}/${version}`);
    isWeb3Injected = web3IsInjected();
    console.info(`web3Enable: Enabled ${values.length} extension${values.length !== 1 ? "s" : ""}: ${names.join(", ")}`);
    return values;
  })));
  return web3EnablePromise;
}
async function web3Accounts({ accountType, extensions, genesisHash, ss58Format } = {}) {
  const accounts = [];
  const sources = await filterEnable("web3Accounts", extensions);
  const retrieved = await Promise.all(sources.map(async ({ accounts: accounts2, name: source }) => {
    try {
      const list = await accounts2.get();
      return mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format);
    } catch {
      return [];
    }
  }));
  retrieved.forEach((result) => {
    accounts.push(...result);
  });
  console.info(`web3Accounts: Found ${accounts.length} address${accounts.length !== 1 ? "es" : ""}`);
  return accounts;
}
async function web3AccountsSubscribe(cb, { accountType, extensions, genesisHash, ss58Format } = {}) {
  const sources = await filterEnable("web3AccountsSubscribe", extensions);
  const accounts = {};
  const triggerUpdate = () => cb(Object.entries(accounts).reduce((result, [source, list]) => {
    result.push(...mapAccounts(source, filterAccounts(list, genesisHash, accountType), ss58Format));
    return result;
  }, []));
  const unsubs = sources.map(({ accounts: { subscribe }, name: source }) => subscribe((result) => {
    accounts[source] = result;
    try {
      const result2 = triggerUpdate();
      if (result2 && isPromise(result2)) {
        result2.catch(console.error);
      }
    } catch (error) {
      console.error(error);
    }
  }));
  return () => {
    unsubs.forEach((unsub) => {
      unsub();
    });
  };
}
async function web3FromSource(source) {
  if (!web3EnablePromise) {
    return throwError("web3FromSource");
  }
  const sources = await web3EnablePromise;
  const found = source && sources.find(({ name }) => name === source);
  if (!found) {
    throw new Error(`web3FromSource: Unable to find an injected ${source}`);
  }
  return found;
}
async function web3FromAddress(address) {
  if (!web3EnablePromise) {
    return throwError("web3FromAddress");
  }
  const accounts = await web3Accounts();
  let found;
  if (address) {
    const accountU8a = decodeAddress(address);
    found = accounts.find((account) => u8aEq(decodeAddress(account.address), accountU8a));
  }
  if (!found) {
    throw new Error(`web3FromAddress: Unable to find injected ${address}`);
  }
  return web3FromSource(found.meta.source);
}
async function web3ListRpcProviders(source) {
  const { provider } = await web3FromSource(source);
  if (!provider) {
    console.warn(`Extension ${source} does not expose any provider`);
    return null;
  }
  return provider.listProviders();
}
async function web3UseRpcProvider(source, key) {
  const { provider } = await web3FromSource(source);
  if (!provider) {
    throw new Error(`Extension ${source} does not expose any provider`);
  }
  const meta = await provider.startProvider(key);
  return { meta, provider };
}
export {
  isWeb3Injected,
  packageInfo9 as packageInfo,
  unwrapBytes,
  web3Accounts,
  web3AccountsSubscribe,
  web3Enable,
  web3EnablePromise,
  web3FromAddress,
  web3FromSource,
  web3ListRpcProviders,
  web3UseRpcProvider,
  wrapBytes
};
//# sourceMappingURL=@polkadot_extension-dapp.js.map
